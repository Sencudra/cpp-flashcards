{
    "__type__": "Deck",
    "children": [],
    "crowdanki_uuid": "4ff52410-cf8d-11f0-98d8-1d42bb598edb",
    "deck_config_uuid": "4ff528d4-cf8d-11f0-98d8-1d42bb598edb",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "answerAction": 0,
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "4ff528d4-cf8d-11f0-98d8-1d42bb598edb",
            "desiredRetention": 0.9,
            "dyn": false,
            "easyDaysPercentages": [
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0
            ],
            "fsrsParams5": [],
            "fsrsParams6": [],
            "fsrsWeights": [],
            "ignoreRevlogsBeforeDate": "1970-01-01",
            "interdayLearningMix": 2,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 10
            },
            "newGatherPriority": 0,
            "newMix": 1,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "questionAction": 0,
            "replayq": true,
            "rev": {
                "bury": false,
                "ease4": 1.3,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 365,
                "perDay": 100
            },
            "reviewOrder": 0,
            "secondsToShowAnswer": 0.0,
            "secondsToShowQuestion": 0.0,
            "sm2Retention": 0.9,
            "stopTimerOnAnswer": true,
            "timer": 1,
            "waitForAudio": true,
            "weightSearch": ""
        }
    ],
    "desc": "",
    "desiredRetention": null,
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [],
    "name": "Learn C++",
    "newLimit": null,
    "newLimitToday": null,
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: left;\n    color: black;\n    background-color: white;\n}\n\n.back {\n\ttext-align: start;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": 1823845765375659412,
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -7436055664692796837,
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Basic",
            "originalStockKind": 1,
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n<div class=\"back\">\n\n{{Back}}\n\n</div>",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": 8982891345828450543,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Front}}"
                }
            ],
            "type": 0
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>statement</b>?",
                "A type of instruction that causes the program to perform some action."
            ],
            "guid": "K./zPoA>zi",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>function</b>?",
                "A collection of statements that execute sequentially."
            ],
            "guid": "vM_3wVZ6$D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>identifier</b>?",
                "The name of a function, object, type, template, etc."
            ],
            "guid": "A$pT#it$+(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>syntax</b>?",
                "The rules that govern how elements of the C++ language are constructed."
            ],
            "guid": "rO9uORsJK3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>data</b>?",
                "Any information that can be moved, processed, and stored by the computer."
            ],
            "guid": "wUc>lywK4g",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>value</b>?",
                "A single piece of data."
            ],
            "guid": "t}a%i<dDJF",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>definition statement</b>?",
                "A statement that is used to create a variable."
            ],
            "guid": "iXY^y6Aaia",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>data type</b>?",
                "A scheme that tells the compiler how to interpret a piece of data into a meaningful value."
            ],
            "guid": "w)=U]f,^(U",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>default initialization</b> look like?",
                "<code>int x;</code> — In most cases, the value is undefined."
            ],
            "guid": "g>h|}yB#oF",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>copy initialization</b> look like?",
                "<code>int x = 5;</code>"
            ],
            "guid": "i&Ye86NQA^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>direct initialization</b> look like?",
                "<code>int x(5);</code>"
            ],
            "guid": "cov7a}7@Ke",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>direct list initialization</b> look like?",
                "<code>int x{5};</code>"
            ],
            "guid": "zV?<:!Q5RT",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>copy list initialization</b> look like?",
                "<code>int x = {5};</code>"
            ],
            "guid": "bb}sq&kd[b",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>value initialization</b> look like?",
                "<code>int x{};</code>"
            ],
            "guid": "xI:Naj)0ya",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>std::endl</b> do?",
                "It moves the cursor to a new line and flushes the buffer (which is slow)."
            ],
            "guid": "P*eE:h_wxY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "IO"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which is better: <b>\\n</b> or <b>std::endl</b>?",
                "Prefer \\n over std::endl due to higher efficiency. There is no need to flush the buffer with \\n."
            ],
            "guid": "eWfPoQ%b]0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "IO"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>uninitialized variable</b>?",
                "A variable that has not been given a value."
            ],
            "guid": "mPtwgtODv#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>keyword</b>?",
                "A language-reserved name."
            ],
            "guid": "M+@<RX9.wA",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>expression</b>?",
                "A sequence of literals, variables, operators, and function calls that evaluates to produce a single output value."
            ],
            "guid": "xUaitrTPS}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>expression statement</b>?",
                "An expression followed by a semicolon."
            ],
            "guid": "K]I-^n?l$W",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>undefined behavior</b>?",
                "The result of executing code whose behavior is not defined by the C++ language."
            ],
            "guid": "dU_L6CZmN(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>implementation-defined behavior</b>?",
                "Behavior that is left up to the implementation and can vary between compilers."
            ],
            "guid": "HQ?pyOp{ab",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>unspecified behavior</b>?",
                "Implementation-defined behavior that may not be documented."
            ],
            "guid": "L*iNEd$WJg",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>callee</b>?",
                "The function being called."
            ],
            "guid": "H(v,{X[7b(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>caller</b>?",
                "The function that initiates the call to another function."
            ],
            "guid": "ohHf/<Oh}S",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean to <b>return by value</b>?",
                "The return value is copied from the function back to the caller."
            ],
            "guid": "g=;D#iG2VA",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean to be <b>passed by value</b>?",
                "The argument is copied into the function parameter."
            ],
            "guid": "LGdKq7$P!#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>forward declaration</b>?",
                "Telling the compiler about the existence of an identifier before actually defining it."
            ],
            "guid": "kP-ZP+L8t9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>function prototype</b>?",
                "A forward declaration for a function."
            ],
            "guid": "A9]2?*`-oc",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>pure declarations</b>?",
                "Declarations that are not definitions."
            ],
            "guid": "E8Tct^!u;c",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>preprocessor</b>?",
                "A special process that runs on the code before compiling."
            ],
            "guid": "gwoM]:B9yw",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Preprocessor"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>preprocessor directives</b>?",
                "Special instructions to the preprocessor."
            ],
            "guid": "EBWk80.:{<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Preprocessor"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>macro</b>?",
                "A rule that defines how input text is converted to replacement output text."
            ],
            "guid": "q~QA3Xuf!7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Preprocessor"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>syntax error</b>?",
                "An error that occurs when you write a statement that is not valid according to the grammar of the C++ language."
            ],
            "guid": "CU:+}iEqI6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>semantic error</b>?",
                "An error where a statement is syntactically valid but does not do what the programmer intended."
            ],
            "guid": "vVtu~_,HP]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>debugging</b>?",
                "The process of removing errors from a program."
            ],
            "guid": "Lx*y6M!89_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Debugging"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the steps to approach debugging?",
                "1. Find the root cause<br>2. Understand the problem<br>3. Determine a fix<br>4. Repair the issue<br>5. Retest"
            ],
            "guid": "sF5tz]rq4w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Debugging"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>recursive function</b>?",
                "A function that calls itself."
            ],
            "guid": "gzp``pL@BO",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What <b>fundamental data types</b> does C++ have?",
                "Floating-point (float, double, long double), integral (bool, char, int, long), nullptr, void"
            ],
            "guid": "L;Tw|=O0L)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the smallest unit of memory?",
                "A bit."
            ],
            "guid": "LFPMVsE6?~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the smallest addressable unit of memory in C++?",
                "A byte."
            ],
            "guid": "LYeC/l:qCm",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which C++ type represents no type?",
                "<code>void</code>"
            ],
            "guid": "Ga8A]c?c<F",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the <b>int</b> type always 4 bytes wide?",
                "No, the size varies by platform. For consistent sizes, use fixed-width types like <code>int32_t</code>."
            ],
            "guid": "iZXI}sxx&|",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you determine the size of a type?",
                "Use the <code>sizeof()</code> operator."
            ],
            "guid": "D+i{zcBSdj",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>_t</b> suffix mean in type names?",
                "It is a naming convention for some (but not all) modern types like <code>size_t</code>, <code>int32_t</code>."
            ],
            "guid": "L%V@o$?F/u",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the limits for <b>signed char</b>?",
                "1 byte, -128 to 127"
            ],
            "guid": "Mw!-W4&e}@",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the limits for <b>unsigned char</b>?",
                "1 byte, 0 to 255"
            ],
            "guid": "OhR!-,I[IL",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the limits for <b>char16_t</b> and <b>char32_t</b>?",
                "2 or 4 bytes, unsigned: 0 to 65,535 (char16_t) or 0 to 1,114,111 (char32_t)"
            ],
            "guid": "F}HNabm(b4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the limits for <b>signed int</b>?",
                "2, 4, or 8 bytes: ±3.2×10⁴, ±2.14×10⁹, or ±9.22×10¹⁸"
            ],
            "guid": "vXu~<0F7@f",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the limits for <b>unsigned int</b>?",
                "2, 4, or 8 bytes: 6.55×10⁴, 4.29×10⁹, or 1.84×10¹⁹"
            ],
            "guid": "JDz6dkc~Eh",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>type conversion</b>?",
                "The process of converting a value from one type to another data type."
            ],
            "guid": "poX>JE2Jy=",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>implicit type conversion</b>?",
                "Automatic conversion performed by the compiler when a different type is supplied than expected. Includes numeric promotions, numeric conversions, and pointer conversions. Also called coercion."
            ],
            "guid": "x|ITMWDIWS",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>value-preserving conversion</b>?",
                "A conversion where there is no loss of value or precision."
            ],
            "guid": "xPJ$RVybWC",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>reinterpretive conversion</b>?",
                "A conversion where the value is changed but there is no loss of data or precision."
            ],
            "guid": "LI}vniv{zK",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>narrowing conversion</b>?",
                "A conversion that may result in the loss of value or precision."
            ],
            "guid": "F6F8S_Au.i",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>numeric promotion</b>?",
                "Conversion of smaller numeric types to larger types (like <code>int</code> or <code>double</code>) so the CPU can operate more efficiently. Includes integral and floating-point promotions."
            ],
            "guid": "DqGF<amjBQ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the rules for <b>integral numeric promotions</b>?",
                "<ol>\n<li>signed char/short → int</li>\n<li>unsigned char, char8_t, short → int if it fits, otherwise unsigned int</li>\n<li>bool → int</li></ol>"
            ],
            "guid": "ntY!&n4F:N",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the rule for <b>floating-point promotion</b>?",
                "<code>float</code> → <code>double</code>"
            ],
            "guid": "spwN&#UQR*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>numeric conversion</b>?",
                "Any type conversion that is not a numeric promotion."
            ],
            "guid": "KIz7P!&qun",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>explicit type conversion</b>?",
                "When the programmer explicitly requests conversion to a specific type via a cast."
            ],
            "guid": "h>l!mAl[tR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What <b>cast operators</b> are available in C++?",
                "5 types: <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>, and C-style casts. Avoid using <code>const_cast</code>, <code>reinterpret_cast</code>, and C-style casts."
            ],
            "guid": "yvQ))YWrHD",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>reinterpret_cast</b>?",
                "A cast that reinterprets the bit-level representation of a type."
            ],
            "guid": "EYv-zh+aso",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why should C-style casts be avoided?",
                "C-style casts can perform any cast including <code>const_cast</code> or <code>reinterpret_cast</code> without explicitly showing which one. Named casts are clearer and safer."
            ],
            "guid": "Ijms<+>s|z",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can <b>constexpr</b> help in numeric conversion?",
                "It can help avoid narrowing conversion errors at compile time."
            ],
            "guid": "I%p~:80M.7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion", "Constexpr"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a <b>type alias</b>?",
                "<code>using NewType = OldType;</code>"
            ],
            "guid": "B3c5%ZD1OM",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Do these compile?<br><ol><li><code>int c { 5.4 };</code></li><li><code>float i { doubleVariable };</code></li><li><code>float j { 5.0 };</code></li></ol>",
                "<ol><li>No — narrowing conversions are prohibited in brace initialization.</li><li>No — narrowing conversion from <code>double</code> to <code>float</code>.</li><li>Yes — <code>5.0</code> is a constexpr value that fits in <code>float</code>.</li></ol>"
            ],
            "guid": "g|3r#BL~S?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Initialization", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>operation</b>?",
                "A mathematical process involving zero or more input values, called operands."
            ],
            "guid": "P)l7]h%[^#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>operator</b>?",
                "A specific operation denoted by a construct (typically a symbol)."
            ],
            "guid": "sTM1%!d`o",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>operator precedence</b>?",
                "The rules that determine how operands are grouped in compound expressions. Higher precedence operators bind more tightly than lower precedence ones."
            ],
            "guid": "NWhS$;25LO",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>operator associativity</b>?",
                "Associativity tells the compiler how to group operands when operators have the same precedence value: right-to-left or left-to-right."
            ],
            "guid": "P(Oj%52t/|",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the highest <b>operator precedence</b> level in C++?",
                "Level 1 is the highest precedence, and level 17 is the lowest."
            ],
            "guid": "O/`[?Jj/P0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the order of operand evaluation with the comma operator? And in argument lists?",
                "With the comma operator: left to right. In function argument lists: unspecified (not the comma operator, just a separator)."
            ],
            "guid": "E2ZFp<p<l9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>modifying operators</b>?",
                "Operators that not only calculate and return a value but also modify their left operand. There are two groups: assignment operators and increment/decrement operators."
            ],
            "guid": "Lbn3.},1@y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is the <b>postfix increment</b> operator evaluated?",
                "<ol><li>A copy of the value is made</li><li>The variable is incremented</li><li>The copy is returned</li></ol>"
            ],
            "guid": "D@NR~T}1s^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kind of associativity does the <b>comma operator</b> have?",
                "Left-to-right."
            ],
            "guid": "f=c^=5Ojp,",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Do comma operator associativity rules apply to function argument lists?",
                "No. Commas in argument lists are separators, not the comma operator. Argument evaluation order is unspecified."
            ],
            "guid": "L$H}=ZKs<1",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <code>!!</code> idiom?",
                "Two logical NOT operators used to convert any value to <code>bool</code>. The first <code>!</code> converts to bool and negates, the second negates back."
            ],
            "guid": "LM`e.53a/v",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the <b>sublanguages</b> of C++? Why is it important to distinguish them?",
                "C, Object-Oriented C++, Template C++, and the STL. Each has its own rules for effective programming."
            ],
            "guid": "w<ud3&q+Fq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>execution path</b>?",
                "The specific sequence of statements that the CPU executes."
            ],
            "guid": "Od;51ItZ]Q",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>control flow statements</b>?",
                "Statements that allow the programmer to change the normal path of execution through the program."
            ],
            "guid": "d;o@Yz:eb`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the main categories of control flow statements?",
                "1. Conditional statements (if, switch)<br>2. Loops (for, while, do-while)<br>3. Jump statements (break, continue, return, goto)<br>4. Function calls<br>5. Halts (exit, abort)<br>6. Exceptions"
            ],
            "guid": "fNey-X~KZd",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a conditional statement?",
                "A statement that selects whether associated code should execute based on a condition. Examples: <code>if</code>, <code>switch</code>."
            ],
            "guid": "j==%>Xv4AZ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>null statement</b>?",
                "An expression statement that consists of just a semicolon."
            ],
            "guid": "C^wQ!RrA>B",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What types can be used with a <b>switch</b> statement?",
                "Only integral types."
            ],
            "guid": "B)>w!=4(&D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why can only integral types be used with the <b>switch</b> statement?",
                "Switch statements are designed to be highly optimized and are implemented via jump tables."
            ],
            "guid": "z}Q2naQv+5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the order of execution for the different parts of a <b>for-statement</b>?",
                "Init-statement, condition, loop body, and end-expression."
            ],
            "guid": "D)vDU[d1*D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a halt?",
                "A control flow statement that immediately terminates program execution. Examples: <code>std::exit</code>, <code>std::abort</code>."
            ],
            "guid": "DAhw;>?SLY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens when program flow reaches the end of <b>main()</b>?",
                "<ol><li>All local variables are destroyed</li><li><code>std::exit</code> is called with the return value of main.</li></ol>"
            ],
            "guid": "ox)XDLhNfR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>std::exit()</code> do?",
                "Terminates the program normally. Calls <code>atexit</code> handlers, flushes streams, and destroys static objects. Does NOT unwind the stack or call local destructors."
            ],
            "guid": "LUoi(d8$WO",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>std::atexit()</b>?",
                "A function that registers cleanup functions to be called when the program terminates normally."
            ],
            "guid": "D50RMDGy#t",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In what order are <b>std::atexit</b> handlers called if there are several defined?",
                "In reverse order. The last defined handler is executed first."
            ],
            "guid": "AKIBU5v+<A",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>std::abort</b>?",
                "A function for abnormal program termination. <code>std::abort</code> is called by <code>std::terminate</code>."
            ],
            "guid": "uF|Pog}AD3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an algorithm?",
                "A finite, well-defined sequence of steps to solve a problem or perform a computation."
            ],
            "guid": "G.QVsbt1Rn",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a compound (composite) data type?",
                "A type constructed from other types. Examples: arrays, pointers, references, functions, classes, enums."
            ],
            "guid": "HK[F%1{m#d",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of <b>compound data types</b> exist in C++?",
                "7 cases:<br><ul><li>Functions</li><li>C-style arrays</li><li>pointer types (objects, functions)</li><li>pointer to member types (data, function)</li><li>reference values (L-value, R-value)</li><li>enums (scoped and unscoped)</li><li>class types (structs, classes, unions)</li></ul>"
            ],
            "guid": "mrTBi/wERX",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>value category</b> of an expression?",
                "A value category indicates whether an expression resolves to a value, a function, or an object of some kind. There are 5 value categories: <b>rvalue (prvalue, xvalue)</b>, <b>lvalue (glvalue)</b>."
            ],
            "guid": "KeK>}gGO!M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Value-Categories"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>lvalue expression</b>?",
                "An expression that evaluates to an identifiable object or function. It can be <b>modifiable</b> or <b>non-modifiable</b>."
            ],
            "guid": "sqJ?./SfI6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Value-Categories"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>rvalue expression</b>?",
                "Everything that is not an lvalue; an expression that evaluates to a value that cannot be identified (e.g., temporaries, literals)."
            ],
            "guid": "B+D+-SD~Y#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Value-Categories"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can an <b>lvalue</b> be used where an <b>rvalue</b> is expected?",
                "Yes, but not the reverse."
            ],
            "guid": "g#bmZgTHfy",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Value-Categories"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>reference</b>?",
                "An alias for an existing object."
            ],
            "guid": "yH-]1CJGyP",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of <b>references</b> exist?",
                "Lvalue references and rvalue references."
            ],
            "guid": "Q~Y@*P48^t",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Must a <b>reference</b> be initialized?",
                "Yes, references must be initialized when declared."
            ],
            "guid": "dkV~wV~[P&",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is this valid code?<br><pre><code class=\"language-cpp\">int x{5};\ndouble&amp; y{x};</code></pre>",
                "No, the result of evaluating <code>x</code> requires a conversion, which produces an rvalue. You cannot bind an rvalue to an lvalue reference."
            ],
            "guid": "Q|vp&w*r7L",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a dangling reference?",
                "A reference that refers to an object that no longer exists. Accessing a dangling reference is undefined behavior."
            ],
            "guid": "N2Ho7{V&cg",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a temporary object?",
                "An unnamed (anonymous) object created to hold a value for a short duration, typically destroyed at the end of the full expression."
            ],
            "guid": "qo?q9FJ<a<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Value-Categories"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the output of this code?<br><pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nint main() {\n    short bombs { 1 };\n    const int&amp; you { bombs };\n    --bombs;\n    if (you) {\n        std::cout &lt;&lt; \"Bombs away!\\n\";\n    }\n    return 0;\n}</code></pre>",
                "\\\"Bombs away!\\\" is printed because binding a <code>const int&amp;</code> to a <code>short</code> creates a temporary (due to integral promotion), so <code>you</code> still holds 1."
            ],
            "guid": "E%@gC&-8U7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "References", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What can you bind to an <b>lvalue reference</b>?",
                "Only modifiable lvalues."
            ],
            "guid": "jH~x|tA]Q{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What can you bind to an <b>lvalue reference to const</b>?",
                "Can be bound to modifiable lvalues, non-modifiable lvalues, and rvalues."
            ],
            "guid": "Q!c!rNmFq$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can you avoid expensive <b>copying</b> of objects?",
                "Pass by reference."
            ],
            "guid": "LmW<`@h@a9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of <b>conversions</b> exist in terms of data safety?",
                "Conversions can be either safe (value-preserving), reinterpretive (value is different but no data loss) or unsafe (lossy data conversions)."
            ],
            "guid": "I0_p_957YR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What types are <b>cheaper to copy</b> than pass by reference?",
                "Types that are equal to or smaller than two words (typically 16 bytes on 64-bit systems)."
            ],
            "guid": "H?[U<7nC1#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>address-of operator</b>?",
                "<code>&amp;</code>"
            ],
            "guid": "HmB+LI-.uF",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <code>&amp;</code> symbol mean in: <code>int&amp; ref</code>?",
                "Lvalue reference."
            ],
            "guid": "w}TJAu)*qx",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <code>&amp;</code> symbol mean in: <code>std::cout &lt;&lt; &amp;x</code>?",
                "Address-of operator."
            ],
            "guid": "J:bt@@IcT@",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <code>&amp;</code> symbol mean in: <code>std::cout &lt;&lt; x &amp; y</code>?",
                "Bitwise AND operator."
            ],
            "guid": "z#y!I_;{(*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>dereference operator</b>?",
                "<code>*</code>, returns the value at a given address as an lvalue."
            ],
            "guid": "z3h4f{>Of)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a pointer?",
                "An object that holds a memory address as its value, typically the address of another variable."
            ],
            "guid": "zX.Oo_Sxa>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>null pointer</b>?",
                "A pointer that is not pointing at anything. E.g., <code>int* p{}</code> or <code>int* p = nullptr</code>."
            ],
            "guid": "dB:%9CL]|=",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens when you dereference a <b>null pointer</b>?",
                "It's undefined behavior."
            ],
            "guid": "L@O%u^!iXm",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you check if a pointer is a <b>null pointer</b>?",
                "With a conditional statement: <code>if (ptr)</code> or <code>if (ptr != nullptr)</code>."
            ],
            "guid": "ez2}Q!Wl.6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a wild pointer?",
                "An uninitialized pointer that contains an indeterminate (garbage) address. Dereferencing is undefined behavior."
            ],
            "guid": "B[Ap+CY,k}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the key differences between <b>pointers</b> and <b>references</b>?",
                "<ol><li>Pointers are objects</li><li>Pointers can change what they are pointing at</li><li>Pointers can point to nothing</li><li>Pointers are much more dangerous to use</li></ol>"
            ],
            "guid": "E$v|pBIHH3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>address-of operator</b> return?",
                "A pointer to the address."
            ],
            "guid": "ho%#{4/|V(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the size of a pointer?",
                "Architecture-dependent. Typically 4 bytes on 32-bit systems and 8 bytes on 64-bit systems."
            ],
            "guid": "mD[DIb}1j6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a dangling pointer?",
                "A pointer that holds the address of an object that has been destroyed or deallocated. Accessing it is undefined behavior."
            ],
            "guid": "tCCRl-N-zf",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the null pointer literals <code>0</code> and <code>NULL</code> used for?",
                "These are legacy literals. They should be avoided as they can cause problems with overloaded functions."
            ],
            "guid": "L882U-ZaTl",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>const pointer</b>? How do you define it?",
                "<code>int* const ptr{};</code> — a pointer that cannot be reassigned."
            ],
            "guid": "j9i5[Ug!Y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a <b>pointer to const</b>?",
                "<code>const int* ptr;</code> — cannot modify the value through the pointer."
            ],
            "guid": "w5VSB&fA[7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you create a <b>pointer to a reference</b>?",
                "No, because pointers must hold addresses of objects, and references are not objects."
            ],
            "guid": "t]D#Vs?hdP",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you create a reference to a pointer?",
                "Yes. Example: <code>int* ptr = nullptr; int*&amp; refToPtr = ptr;</code>"
            ],
            "guid": "NP3@PB-#iu",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the type of <code>nullptr</code>?",
                "<code>std::nullptr_t</code>"
            ],
            "guid": "tkcHQ3m@_}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In what sense is everything in C++ passed by value?",
                "Even references and pointers are copied when passed - the reference or address itself is copied from caller to callee. The underlying semantics is always value-copy."
            ],
            "guid": "h_o,B2H8o{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the consequences of using type deduction via <code>auto</code>?",
                "Type deduction will drop top-level const and references."
            ],
            "guid": "ee[@G#krB}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Auto", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between <b>top-level</b> and <b>low-level const</b>?",
                "Top-level const is applied to an object itself. Low-level const is applied to the object being referenced or pointed to."
            ],
            "guid": "n-[{f6FM[%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you get a value from <code>std::optional</code>?",
                "<ol><li>Dereferencing, UB if no value</li><li><code>value()</code> method, throws exception if there is no value</li><li><code>value_or()</code> with default value</li></ol>"
            ],
            "guid": "ccuk{veoM$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>function overloading</b>?",
                "Function overloading allows you to create multiple functions with the same name, as long as each identically named function has different parameter types or the function can be otherwise differentiated."
            ],
            "guid": "I;k-uHuZH{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>overloaded function</b> or <b>overload</b>?",
                "Functions that share the same name."
            ],
            "guid": "L#=OhP]`bS",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if the compiler cannot differentiate overloaded functions?",
                "Compilation error - the overloads are considered ambiguous or redefinitions."
            ],
            "guid": "Dw=tF_u1J/",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>overload resolution</b>?",
                "The process of matching a function call to the appropriate overload."
            ],
            "guid": "P~(PkVJqaf",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the rules for a program to compile when using overloads?",
                "Overloads must be differentiated and function calls must be resolved."
            ],
            "guid": "h;:BCF}%{?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are overloads differentiated?",
                "Based on number of parameters, type of parameters (excluding typedefs, aliases, const, ellipses) and NOT the return type. For member functions, const/volatile and ref-qualifiers are used."
            ],
            "guid": "AsvSlN:GFo",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the return type used for overload differentiation?",
                "No."
            ],
            "guid": "jWQE>G84Bx",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a function's type signature?",
                "The parts of a function used for overload differentiation: name, number/types of parameters, and function-level qualifiers (const, volatile, ref-qualifiers). Excludes return type."
            ],
            "guid": "Q)vGsHgBVW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>name mangling</b>?",
                "A technique where the compiler generates a special name for functions so the linker can uniquely differentiate them."
            ],
            "guid": "BaQy(L=Tte",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Linker"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the steps the compiler takes to resolve an overload?",
                "<ol><li>Find exact match, or try trivial conversions (lvalue-to-rvalue, qualification, non-reference to reference)</li><li>Apply numeric promotions</li><li>Apply numeric conversions</li><li>Apply user-defined conversions</li><li>Find function that uses ellipsis</li><li>Give up and report compilation error</li></ol>"
            ],
            "guid": "AOqMLM2eO*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>ambiguous match</b>?",
                "When 2 or more overloads are equally good matches for a function call."
            ],
            "guid": "2P$i_YERV",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you resolve an <b>ambiguous match</b> error?",
                "<ol><li>Explicitly define the required function</li><li>Use a cast for arguments</li><li>Use a literal suffix</li></ol>"
            ],
            "guid": "m<5whF1~>w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <code>= delete</code> specifier do?",
                "Marks a function as deleted, making it unavailable. Any attempt to use it causes a compilation error."
            ],
            "guid": "tU=r@h)[dd",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>default argument</b>?",
                "An argument with a default value provided."
            ],
            "guid": "zNc(tH:2;A",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Do <b>default arguments</b> work for calls via function pointers?",
                "No, because default arguments are resolved at compile-time."
            ],
            "guid": "Nh1%1dj<~{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a template?",
                "A blueprint for creating functions or classes using placeholder (generic) types that are substituted with actual types at compile time."
            ],
            "guid": "b^49(OGt?g",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a function template?",
                "A function-like definition used to generate one or more overloaded functions, each with a different set of concrete types."
            ],
            "guid": "x;_WuUOaH<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>primary function template</b>?",
                "The initial function template used to generate other functions."
            ],
            "guid": "Ho7&QUqaug",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>instantiated functions</b>?",
                "Functions that are generated from a primary template."
            ],
            "guid": "Nyr3#2!XhY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of <b>template parameters</b> are supported?",
                "Type, non-type (constexpr value), and template."
            ],
            "guid": "P:+avc[dRh",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a template?",
                "Via a template parameter declaration: <code>template &lt;typename T&gt;</code> or <code>template &lt;class T&gt;</code>"
            ],
            "guid": "x7/YImHOu]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "If <code>max(int, int)</code> function exists, what will be called?<br><br>1. <code>max&lt;&gt;(int, int)</code><br>2. <code>max(int, int)</code>",
                "1. The template<br>2. The non-template function"
            ],
            "guid": "l_|cqf_!Q+",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you use <code>= delete</code> with templates?",
                "Yes, to remove specific signatures you don't want users to use."
            ],
            "guid": "GQD$[aa}tG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Will different versions of a template have the same <b>static local variable</b>?",
                "No, each version has its own variable."
            ],
            "guid": "I^[@==E_hV",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the drawbacks of using <b>function templates</b>?",
                "<ul><li>Compiler creates all used versions, increasing binary size (code bloat)</li><li>Complex error messages that are hard to debug</li></ul>"
            ],
            "guid": "k[7qy<R0TW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>non-type template parameter</b>?",
                "A template parameter that is a value instead of a type. Can be: integral, enumeration, nullptr, floating point (C++20), pointers, or literal class types."
            ],
            "guid": "nk77v6$%J&",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>user-defined types</b>?",
                "Also called <b>program-defined types</b>. Types that the programmer creates to use in a program."
            ],
            "guid": "Au]E:QC4z)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the categories of compound types used to create <b>user-defined types</b>?",
                "<ul><li>Enumerated types (scoped/unscoped enumerations)</li><li>Class types (struct, class, union)</li></ul>"
            ],
            "guid": "g`E~N,8L9|",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a type definition?",
                "The definition of a user-defined (program-defined) type, specifying its name and structure."
            ],
            "guid": "AT7@KcN7bU",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>enumeration</b>?",
                "A compound data type whose values are restricted to a set of named symbolic constants, called enumerators."
            ],
            "guid": "OeA!p6xP/M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What types of <b>enumerations</b> are available in C++?",
                "Scoped and unscoped."
            ],
            "guid": "M6)Sq,Y#J$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the scope of <b>unscoped enumerations</b>?",
                "Enumerator names are placed in the same scope as the enumeration itself."
            ],
            "guid": "y27Ob~b1yA",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the best way to avoid name collision with <b>unscoped enums</b>?",
                "Use namespaces."
            ],
            "guid": "q4@&]uBE3:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the default integral value of the first enumerator in an enum?",
                "0"
            ],
            "guid": "PiGx|ZqhAA",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an enumeration's underlying type?",
                "The specific integral type used to store the enumerator values. Can be specified explicitly or determined by the compiler."
            ],
            "guid": "mx.=i(<zzF",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a scoped enumeration?",
                "An enumeration declared with <code>enum class</code> or <code>enum struct</code>. Enumerators are scoped and don't implicitly convert to integers."
            ],
            "guid": "LoEzwq(/<:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the key differences between scoped and unscoped enums?",
                "1. Scoped enums don't implicitly convert to integers<br>2. Scoped enum enumerators are only accessible via the enum name (e.g., <code>Color::Red</code>)<br>3. Scoped enums have a defined underlying type (<code>int</code> by default)"
            ],
            "guid": "DbbyF$Cgex",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a <b>scoped enum</b>?",
                "<code>enum class</code> or <code>enum struct</code>"
            ],
            "guid": "qI]&|ULi6N",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Enums"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an aggregate in C++?",
                "A type that can be initialized with aggregate initialization (brace-init list). Either a C-style array or a class type with: no user-declared constructors, no private/protected non-static data members, no virtual functions, no virtual/private/protected base classes."
            ],
            "guid": "s`I+(rr0jz",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the equivalent of <code>ptr-&gt;id</code>?",
                "<code>(*ptr).id</code>"
            ],
            "guid": "ln6cQ}{L_^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Pointers", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is CTAD?",
                "Class Template Argument Deduction (C++17). Allows the compiler to deduce template type arguments from constructor arguments: <code>std::pair p{1, 2.0};</code> deduces <code>std::pair&lt;int, double&gt;</code>."
            ],
            "guid": "ky$o!8ATbw",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>subexpression</b>?",
                "An expression used as an operand."
            ],
            "guid": "y4nYIr8d<^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>full expression</b>?",
                "An expression that is not a subexpression."
            ],
            "guid": "l/:l8@4Ytd",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>procedural programming</b>?",
                "A programming paradigm focused on creating procedures (functions) that implement program logic."
            ],
            "guid": "DliAD1K7^?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>Object-Oriented Programming</b>?",
                "A programming paradigm focused on creating program-defined data types that contain both properties and a set of well-defined behaviors."
            ],
            "guid": "brGh-Wsr7;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>class invariant</b>?",
                "A condition that must be true throughout the lifetime of an object for it to remain in a valid state."
            ],
            "guid": "j`^_m<kxVi",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>member functions</b>?",
                "Functions that belong to a class type."
            ],
            "guid": "dqHbwInI|k",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are free functions?",
                "Functions that are not member functions of a class. Also called non-member functions or standalone functions."
            ],
            "guid": "CZ4f;j`&-w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>implicit object</b>?",
                "The object that a member function is called on."
            ],
            "guid": "mMrkrP%3^,",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can structs have constructors?",
                "Yes, but adding a user-declared constructor makes the struct a non-aggregate, losing aggregate initialization. Keep structs as simple aggregates when possible."
            ],
            "guid": "GVHCIs)z1_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can a <b>class</b> have no data members?",
                "Yes, but you should use a namespace instead."
            ],
            "guid": "E8tJzh}f,,",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens when you declare an object of a class type as const?",
                "You cannot modify any members or call non-const member functions on it. You can still call const member functions and non-member functions."
            ],
            "guid": "MPbikmEz1-",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>const member function</b>?",
                "A member function that guarantees it will not modify the object or call any non-const member functions."
            ],
            "guid": "F7mPQkSdOB",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Classes", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can <b>constructors</b> be const?",
                "No, as they need to initialize data members."
            ],
            "guid": "f>5]/eaV6Y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can member functions be overloaded on const?",
                "Yes, const is part of the function signature. A const and non-const version can coexist."
            ],
            "guid": "t5Mc-,z,!6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>access level</b> for a class member?",
                "A property that determines who can access that member."
            ],
            "guid": "EZsoxa;*<=",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What types of class member <b>access levels</b> exist?",
                "<code>public</code>, <code>private</code>, <code>protected</code>"
            ],
            "guid": "O{rLg=c0T3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the access control system in C++?",
                "A compile-time mechanism that enforces access restrictions (<code>public</code>, <code>private</code>, <code>protected</code>) on class members."
            ],
            "guid": "oi:Rs44G7A",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the default access level for <b>struct</b> members?",
                "Public"
            ],
            "guid": "P$fm&Y2O{h",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>private members</b> of a class?",
                "Members that can only be accessed by other members of the same class."
            ],
            "guid": "P,()[6(i.@",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can a <b>derived class</b> access <b>protected members</b>?",
                "Yes"
            ],
            "guid": "nIM#l@~T`E",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you access <b>protected members</b> from public code?",
                "No"
            ],
            "guid": "bdx&|P9By@",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the technical and practical difference between <b>structs</b> and <b>classes</b> in C++?",
                "Default access level (public for struct, private for class) and default inheritance (public for struct, private for class)."
            ],
            "guid": "N&x}Lw/M6h",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When should you use <b>structs</b>?",
                "<ol><li>Simple collection of data that does not benefit from restricting access</li><li>Aggregate initialization is sufficient</li><li>No class invariants, no setup needed, no cleanup needed</li></ol>"
            ],
            "guid": "dt[;!yC{m^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an access function (getter/setter)?",
                "A public member function that retrieves or modifies a private member. Useful for maintaining class invariants."
            ],
            "guid": "wx+@>Q5{QC",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How should <b>getters</b> return objects?",
                "By value or by const reference, to prevent modification of the returned object."
            ],
            "guid": "rEtrz{E,r}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What return type should a member function use when returning a reference to a data member?",
                "The same type as the data member to avoid unnecessary conversions. Consider returning by const reference to prevent modification."
            ],
            "guid": "tpq,hmy>~4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you safely work with functions that return by reference?",
                "1. Use the returned reference immediately<br>2. Don't save references for later use (they may dangle)<br>3. Make a copy if you need to store the value"
            ],
            "guid": "sl-I_qlV(;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "References"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a class interface?",
                "The public interface of a class - the set of public members that define how users interact with objects of that class."
            ],
            "guid": "$`bxRG/i%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the implementation of a class?",
                "The private code that makes the class work - member variables and private member function definitions that users don't need to see."
            ],
            "guid": "x7beBd)NPR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>data hiding</b>?",
                "Also called information hiding or data abstraction. A technique used to enforce separation of interface and implementation by hiding the implementation of a data type from users."
            ],
            "guid": "BA1z,JJybw",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <b>encapsulation</b> mean?",
                "One of two meanings:<br><ol><li>Enclosing of one or more items within a container</li><li>The bundling of data and functions for operation on instances of that data</li></ol>"
            ],
            "guid": "M5y1xi3P;|",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the benefits of data hiding?",
                "1. Reduced complexity - simpler to use<br>2. Maintains class invariants<br>3. Better error detection/handling<br>4. Implementation can change without breaking code<br>5. Easier to debug"
            ],
            "guid": "Gfb4=S/[/;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why prefer non-member non-friend functions over member functions?",
                "Non-member functions increase encapsulation - they can only access the public interface. Fewer member functions means a simpler class with less coupled code."
            ],
            "guid": "p>5WP]kVpM",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What should you think of when considering encapsulation, according to Scott Meyers?",
                "When you think about encapsulation, you should think non-member functions."
            ],
            "guid": "q}{$YSMxco",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you evaluate the degree of <b>encapsulation</b>?",
                "Measure how many public places would be affected by a change. If external code is affected, that code is not well encapsulated."
            ],
            "guid": "Mm5YoSYJ)e",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you decide if a function should be a member or non-member?",
                "1. Virtual function → member<br>2. Operator overload → non-member (friend if needs private access)<br>3. Type conversion → non-member<br>4. Can implement via public interface → non-member<br>5. Otherwise → member"
            ],
            "guid": "xfGE8X3cEE",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>constructor</b>?",
                "A special member function that is automatically called after a non-aggregate class type object is created."
            ],
            "guid": "vv)7U;uR_^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are the arguments of a <b>constructor</b> convertible?",
                "Yes"
            ],
            "guid": "j1aDf]YQ0V",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between using <b>constructors</b> and <b>setters</b>?",
                "Constructors are designed to initialize an entire object. Setters are designed to assign a value to a single member of an existing object."
            ],
            "guid": "ieix{e_mHm",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a member initializer list?",
                "The part of a constructor after the colon that directly initializes members: <code>Foo(int x) : a(x), b() { }</code>. More efficient than assignment in the body."
            ],
            "guid": "H[U~UrHDD{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Constructors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In what order are members in a <b>member initializer list</b> initialized?",
                "In the order they are defined inside the class, not the order in the initializer list."
            ],
            "guid": "cN(x)|r>[u",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the options to initialize a member (in order of precedence)?",
                "<ol><li>Value from member initializer list</li><li>Default member initializer</li><li>Default-initialized</li><li>Compilation error</li></ol>"
            ],
            "guid": "K5oWbsGg+y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When does the <b>constructor body</b> get called?",
                "After the member initializer list has executed."
            ],
            "guid": "n#IXrxi`^O",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is an object considered initialized and constructed?",
                "After executing the member initializer list and the constructor body exits."
            ],
            "guid": "IC[~^ZbeG)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the common strategies for dealing with errors?",
                "<ul><li>Resolve the error within the function</li><li>Pass the error back to the caller to deal with</li><li>Halt the program</li><li>Throw an exception</li></ul>"
            ],
            "guid": "ob+gs%`!^7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the best way to handle errors in <b>constructors</b>?",
                "Throw an exception."
            ],
            "guid": "I^i--pA3k4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>default constructor</b>?",
                "A constructor that accepts no arguments."
            ],
            "guid": "j]eOG;^O9D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can constructors be overloaded?",
                "Yes. Constructors are functions and can be overloaded based on parameter types and count."
            ],
            "guid": "Beu0|=!A)F",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Constructors", "Overloading"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an <b>implicit default constructor</b>?",
                "A constructor that is created by the compiler when there is no user-declared constructor."
            ],
            "guid": "s*=-z!kG-x",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is better: a <b>defaulted default constructor</b> or an empty user-defined constructor?",
                "Defaulted is safer (all values are default-initialized) but empty user-defined can be more efficient."
            ],
            "guid": "MR)ORk|{ce",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>delegating constructor</b>?",
                "A constructor that delegates initialization to another constructor from the same class type."
            ],
            "guid": "dMV6yb[:ut",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>copy constructor</b>?",
                "A constructor used to initialize an object with an existing object of the same type."
            ],
            "guid": "CUB93^!$y8",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is a <b>copy constructor</b> implicitly available by default?",
                "Yes, the default copy constructor does memberwise initialization."
            ],
            "guid": "BTNU,h=`U<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does <b>access control</b> work on a per-class or per-object basis?",
                "Per-class basis. Within the same class, you can access private members of a different object of that class."
            ],
            "guid": "kvVXb+tB+i",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>rule of three</b>?",
                "If a class requires a user-defined copy constructor, destructor, or copy assignment operator, then it probably requires all three."
            ],
            "guid": "s{D6~=.ytH",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>rule of five</b>?",
                "The rule of three expanded to include the move constructor and move assignment operator."
            ],
            "guid": "I)IS|?7R-_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why must copy constructors take their parameter by reference, not by value?",
                "Passing by value would require copying the argument, which calls the copy constructor, causing infinite recursion."
            ],
            "guid": "e)e+*z]]{m",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Copy-Semantics", "Constructors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>copy elision</b>?",
                "A compiler optimization technique that allows removing unnecessary copying of objects. When optimized, the copy constructor has been elided."
            ],
            "guid": "xqd.}CS|dD",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it allowed for a <b>copy constructor</b> to produce side effects?",
                "Allowed but not recommended, because copy elision may elide the copy constructor."
            ],
            "guid": "b5+l#USc(c",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the compiler's <b>as-if rule</b>?",
                "The compiler can modify a program in any way to produce more optimized code, as long as those modifications do not affect a program's observable behavior."
            ],
            "guid": "C_[F.)}~TQ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a converting constructor?",
                "A constructor that can be used for implicit type conversion. By default, all single-argument constructors are converting constructors unless marked <code>explicit</code>."
            ],
            "guid": "lsP-N*B,X;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constructors", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <code>explicit</code> keyword?",
                "Tells the compiler that a constructor should not be used as a converting constructor."
            ],
            "guid": "dQ{Ribe,U5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How many user-defined conversions can be applied?",
                "Only one."
            ],
            "guid": "L8MraHs]It",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which constructors should NOT be made <code>explicit</code>?",
                "Copy and move constructors (they don't perform conversions), and constructors with multiple arguments."
            ],
            "guid": "^rkCzsF%X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which constructors should usually be <code>explicit</code>?",
                "Constructors with a single argument, to prevent unintended implicit conversions."
            ],
            "guid": "H+d#l5&$~i",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>literal type</b>?",
                "Any type for which it might be possible to create an object within a constant expression."
            ],
            "guid": "O(ReUdb910",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Constexpr"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the <code>constexpr</code> qualifier part of a function's signature?",
                "No, <code>constexpr</code> is not part of the function signature. You cannot overload based solely on constexpr."
            ],
            "guid": "ydNpD4h,FG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the three types of memory allocation in C++?",
                "1. Static allocation (global/static variables)<br>2. Automatic allocation (local variables, function parameters - stack)<br>3. Dynamic allocation (heap - using new/delete)"
            ],
            "guid": "g}7~.(AZxa",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>static</b> memory allocation?",
                "Happens for static and global variables."
            ],
            "guid": "OJXf^(:~^l",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>automatic</b> memory allocation?",
                "Happens for function parameters and local variables."
            ],
            "guid": "M3XC,c>w(+",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is similar between <b>static</b> and <b>automatic</b> memory allocation?",
                "Sizes for both are known at compile-time. Allocation and deallocation happen automatically."
            ],
            "guid": "F{{r_KmE5^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is dynamic memory allocation?",
                "Allocating memory at runtime from the heap using <code>new</code>. The programmer controls when memory is allocated and deallocated."
            ],
            "guid": "qW]~0`HZHK",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you create <code>int array[1000000];</code> on the stack?",
                "Only if the stack is large enough. Stack size is limited (typically 1-8 MB). Large arrays should use dynamic allocation."
            ],
            "guid": "L),t[RcY}o",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you allocate a new variable dynamically?",
                "Use the <code>new</code> keyword."
            ],
            "guid": "PN:6#:^Iw;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can <code>new</code> fail?",
                "Yes, <code>std::bad_alloc</code> exception is thrown. Use <code>std::nothrow</code> to return nullptr instead."
            ],
            "guid": "B^rMP6]6Rq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it dangerous to delete <code>nullptr</code>?",
                "No, it does nothing."
            ],
            "guid": "r:mxS)kuBc",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a memory leak?",
                "Dynamically allocated memory that is never freed because the program loses track of its address. Leads to increased memory usage, slowdowns, and eventually crashes."
            ],
            "guid": "i/<b}u=I{E",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>destructor</b>?",
                "A class member function that is executed when an object of that class is destroyed."
            ],
            "guid": "l{wf!j=U%M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When are <b>global variables</b> constructed and destroyed?",
                "Before and after <code>main()</code>."
            ],
            "guid": "lulUV4CaD{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>RAII</b>?",
                "<b>R</b>esource <b>A</b>cquisition <b>I</b>s <b>I</b>nitialization (RAII) is a C++ idiom where resource management is tied to object lifetime. Resources are acquired in the constructor and released in the destructor. It helps prevent memory/resource leaks, undefined behavior, and ensures exception safety."
            ],
            "guid": "j,-UGH%naI",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you allocate an array of int pointers?",
                "<code>int** array[]</code>"
            ],
            "guid": "C8%^oJc2p5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>void pointer</b>?",
                "Also known as a generic pointer, a special type of pointer that can point to objects of any data type."
            ],
            "guid": "k:^8KPTtKE",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you dereference a void pointer?",
                "No, you must cast it to a typed pointer first. Dereferencing void* directly is a compilation error."
            ],
            "guid": "oQGWLazT[7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it possible to delete a <b>void pointer</b>?",
                "No, because the object size is unknown. Must cast beforehand."
            ],
            "guid": "L>7ey^a4Q",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it possible to perform pointer arithmetic on a <b>void pointer</b>?",
                "No, object size is unknown. Must cast beforehand."
            ],
            "guid": "l{Q/LNH1Pn",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between a void pointer and a null pointer?",
                "<b>void*</b> refers to pointer type - can point to any type but must be cast before dereferencing.<br><b>nullptr</b> refers to pointer value - a pointer that doesn't point to any valid address.<br>A void pointer can be null."
            ],
            "guid": "FsudeS2$p.",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a pointer-to-function type?",
                "<code>int (*namePtr)()</code>;"
            ],
            "guid": "yq.#@O=sVX",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Pointers", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the Clockwise/Spiral Rule?",
                "A technique by David Anderson for reading complex C/C++ declarations. Start at the identifier and spiral outward clockwise, reading each element."
            ],
            "guid": "F6MMTeg^hU",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>callback function</b>?",
                "A function that is passed as an argument to another function."
            ],
            "guid": "l-jAvAOc;[",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the main <b>memory segments</b> used by a program?",
                "Code/text, BSS, data, heap, and stack."
            ],
            "guid": "veK[&NyAxR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the code/text memory segment?",
                "The memory segment containing the compiled machine code of the program. It is typically read-only to prevent accidental modification."
            ],
            "guid": "M6em%Z>zvh",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>BSS</b> memory segment?",
                "The uninitialized data segment where zero-initialized global and static variables are stored."
            ],
            "guid": "wAS_Yu167P",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>data</b> memory segment?",
                "The initialized data segment where initialized global and static variables are stored."
            ],
            "guid": "B)b-@7:@*G",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>stack</b> memory segment?",
                "The segment used for function parameters, local variables, and return addresses."
            ],
            "guid": "gc974qr=:)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>__attribute__</b> keyword in GCC?",
                "A GCC extension that allows specifying special attributes of variables, functions, or structure fields."
            ],
            "guid": "F{qvK.HgIQ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Attributes", "Compiler-Extensions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the advantages and disadvantages of using the <b>heap</b>?",
                "<div>Drawbacks:</div><ol>\n<li>Memory allocation on the heap is slow.</li>\n<li>Allocated memory stays until specifically deallocated, which can cause memory leaks.</li>\n<li>Accessing dynamically allocated memory via pointer is slower.</li></ol><div>Benefits:</div><ol>\n<li>Large capacity, can store many objects.</li></ol>"
            ],
            "guid": "j4n;eFO-y}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>call stack</b>?",
                "A data structure that keeps track of all active functions from program start to current execution point, and handles allocation of function parameters and local variables."
            ],
            "guid": "rGIou5+v/{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>data structure</b>?",
                "A mechanism for organizing data so that it can be used efficiently."
            ],
            "guid": "H!^RhY))%)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the advantages and disadvantages of using the <b>stack</b>?",
                "<ol>\n<li>Allocating memory on the stack is fast.</li>\n<li>Memory allocated on the stack stays in scope as long as it is on the stack; destroyed when popped.</li>\n<li>All memory allocated on the stack is known at compile time and accessed via variables.</li>\n<li>Stack is small, not suitable for storing large objects.</li></ol>"
            ],
            "guid": "d9u!u!!,dE",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>recursive termination</b>?",
                "A condition that causes the recursive function to stop calling itself."
            ],
            "guid": "pV|L6Z^ewn",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Recursion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>base case</b> in recursion?",
                "Inputs for which a recursive algorithm trivially produces an output without further recursion."
            ],
            "guid": "LNH<&/6(Hu",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Recursion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>memoization</b>?",
                "A dynamic programming technique that caches the results of expensive function calls to avoid redundant computation."
            ],
            "guid": "MZy6D0s]kw",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why should iterative algorithms be preferred over recursion?",
                "Because there is no stack overhead and no risk of stack overflow."
            ],
            "guid": "p<e@i}8:yh",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Recursion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>lambda expression</b>?",
                "Also known as a lambda or closure — an anonymous function object that can be defined inline."
            ],
            "guid": "l[e_5qDgMJ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the structure of a <b>lambda</b>?",
                "<code>[capture](parameters) -> returnType { statements }</code>"
            ],
            "guid": "PE~I_$M!S4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are lambdas functions?",
                "Not exactly — they are special objects (functors) with an overloaded <code>operator()</code>."
            ],
            "guid": "G_&/yRmYs~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of objects can a lambda access without capturing?",
                "Objects with static storage duration (global/static variables) and constexpr variables."
            ],
            "guid": "q[bQz{[q(5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>capture clause</b>?",
                "A part of lambda syntax used to give a lambda access to variables from the surrounding scope that it normally would not have access to."
            ],
            "guid": "o/FuMpUZCa",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are objects passed via a capture list?",
                "By copy (by default)."
            ],
            "guid": "f0BxDJk|[2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Lambdas"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>this</b> keyword?",
                "A const pointer that holds the address of the current implicit object (the object on which a member function is being called)."
            ],
            "guid": "mH^z%(@}ZS",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Classes", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the type of <code>this</code> in a member function?",
                "A const pointer to non-const object (<code>T* const</code>). In a const member function, it's a const pointer to const object (<code>const T* const</code>)."
            ],
            "guid": "MLoM7UTj:l",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can you reset a class instance to its default state?",
                "<code>*this = ClassName{};</code>"
            ],
            "guid": "K&0Z$oG|9-",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is <code>this</code> a pointer rather than a reference?",
                "Historical reasons - <code>this</code> was introduced before references existed in C++. If designed today, it would likely be a reference."
            ],
            "guid": "Ipd]yqlBdg",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are member functions defined in a header without violating the ODR?",
                "They are implicitly inline."
            ],
            "guid": "u.e1XjC~6X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "ODR"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the advantages of putting class implementation in a separate .cpp file?",
                "<ol><li>Definitions in a .h file clutter up the class definition.</li><li>Changes in .h files require recompiling every file that includes that header.</li></ol>"
            ],
            "guid": "GII;Ym-,K8",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a nested type (member type)?",
                "A type defined inside a class. Accessed using scope resolution: <code>OuterClass::NestedType</code>."
            ],
            "guid": "theB)BcqQ{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the destructor called when <code>std::exit()</code> is called?",
                "No, destructors for local objects are not called. Only destructors for static objects are called."
            ],
            "guid": "PCOs;_$mnt",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Destructors", "RAII"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>friend</b> declaration?",
                "A declaration using the <code>friend</code> keyword that grants another class or function access to private or protected members."
            ],
            "guid": "EnS_P2uOc>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Classes", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a constant?",
                "A value that cannot be changed during program execution."
            ],
            "guid": "qI+p.uLy$(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kinds of constants exist in C++?",
                "Named constants and literal constants."
            ],
            "guid": "v/ffJ#*K4`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>named constants</b>?",
                "Constants that are associated with an identifier: const variables, object-like macros, and enumerated constants."
            ],
            "guid": "E<?P{c%6y:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are symbolic constants?",
                "Another term for named constants - constants with an associated identifier (const variables, enumerators, macros)."
            ],
            "guid": "q{G-!#xYXk",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>literal constants</b>?",
                "Constants that are not associated with an identifier (e.g., <code>42</code>, <code>3.14</code>, <code>\"hello\"</code>)."
            ],
            "guid": "G|66ZwG~,c",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are <b>literals</b>?",
                "Values inserted directly into the code, also called literal constants."
            ],
            "guid": "mg^iK#)(C_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is a literal's type deduced?",
                "From its value and format:<br>- Integer literals default to <code>int</code><br>- Floating-point literals default to <code>double</code><br>- Character literals are <code>char</code><br>- String literals are <code>const char[]</code>"
            ],
            "guid": "fHDE?&@/|w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Literals", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are literal suffixes?",
                "Characters appended to literals to explicitly specify their type, e.g., <code>42u</code> (unsigned), <code>3.14f</code> (float), <code>100L</code> (long)."
            ],
            "guid": "lg`UNKj]^}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>u/U</b> literal suffix mean?",
                "<code>unsigned int</code>"
            ],
            "guid": "p5%ysn4f>L",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>l/L</b> literal suffix mean?",
                "<code>long</code>"
            ],
            "guid": "i{motVf/p_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>ul</b> literal suffix mean?",
                "<code>unsigned long</code>"
            ],
            "guid": "Hc]Z{$_,^^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>ll</b> literal suffix mean?",
                "<code>long long</code>"
            ],
            "guid": "j^{%E<y<`w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>ull</b> literal suffix mean?",
                "<code>unsigned long long</code>"
            ],
            "guid": "Qeo&o1@_dg",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>z</b> literal suffix mean? (C++23)",
                "Signed version of <code>std::size_t</code> (i.e., <code>std::ptrdiff_t</code>)."
            ],
            "guid": "nmKr93N/9i",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Literals", "C++23"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>uz</b> literal suffix mean? (C++23)",
                "<code>std::size_t</code> (unsigned)."
            ],
            "guid": "Q.wf/ii*4u",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Literals", "C++23"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>f</b> literal suffix mean?",
                "<code>float</code>"
            ],
            "guid": "B/s1V&y&#i",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>l/L</b> literal suffix mean for floating-point numbers?",
                "<code>long double</code>"
            ],
            "guid": "J19_3>6v4_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>s</b> literal suffix mean?",
                "<code>std::string</code>"
            ],
            "guid": "hb(>87]4,E",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <b>sv</b> literal suffix mean?",
                "<code>std::string_view</code>"
            ],
            "guid": "PY32<Fv|Up",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Types", "Literals", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>constant variable</b>?",
                "A variable whose value cannot be changed after initialization."
            ],
            "guid": "q8Sa;k/Ou/",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Const", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>constant expression</b>?",
                "An expression that can be evaluated at compile time."
            ],
            "guid": "EaqkhTpbv6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What types of <b>compile-time constants</b> are available?",
                "<ol><li>Literals</li><li>constexpr variables</li><li>const integral variables</li><li>Non-type template parameters</li><li>Enumerators</li></ol>"
            ],
            "guid": "rC]^PDIx7{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the code correct?<br><code>int const sidesInSquare { 4 };</code>",
                "Yes, but it's better to place <code>const</code> before the type for consistency."
            ],
            "guid": "HdLH*OK/Y]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Const", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can const variables be uninitialized?",
                "No, const variables must be initialized at the point of declaration."
            ],
            "guid": "s$qq4T}1|]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Const", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a common naming convention for const variables?",
                "<code>kVariableName</code> (prefixed with 'k') or <code>VARIABLE_NAME</code> (all caps)."
            ],
            "guid": "x9+Z(3R.ND",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Const", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Should you use const for parameters passed by value?",
                "Generally no - the caller doesn't care if the function modifies its local copy. Same applies to return types by value."
            ],
            "guid": "L>}g/419VD",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When should you mark variables as const?",
                "Whenever possible, except for by-value function parameters and by-value return types."
            ],
            "guid": "e+R>w3/j4P",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why prefer const/constexpr over preprocessor macros?",
                "1. Macros don't follow C++ scoping rules<br>2. Macros are harder to debug (no type checking)<br>3. Macros can cause unexpected text substitution issues"
            ],
            "guid": "m2t#!MPRd~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const", "Preprocessor"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>type qualifier</b>?",
                "A keyword applied to a type that modifies how that type behaves. C++ has two type qualifiers: <code>const</code> and <code>volatile</code>."
            ],
            "guid": "wcZ~Bn3lfR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the <b>volatile</b> qualifier?",
                "A qualifier that tells the compiler an object may have its value changed at any time (e.g., by hardware or another thread), preventing certain optimizations."
            ],
            "guid": "I<Ftb@E=si",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Types", "Compiler-Extensions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are cv-qualifiers?",
                "The type qualifiers <code>const</code> and <code>volatile</code>. 'cv' stands for const-volatile."
            ],
            "guid": "d9dz,q-~iR",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Types", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>string</b>?",
                "A collection of sequential characters used to represent text."
            ],
            "guid": "I$i4Sgr%&V",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Strings", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a C-style string?",
                "A null-terminated array of characters (<code>char[]</code>). Lower-level than <code>std::string</code> and requires manual memory management."
            ],
            "guid": "AZ]w_F(qx]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the size of the string literal <code>\"Hello, world!\"</code>?",
                "14 bytes - 13 visible characters plus the implicit null terminator (<code>'\\0'</code>)."
            ],
            "guid": "A:I-%3uZhl",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <span style=\"font-weight:600\">null-terminator</span>?",
                "It is \\0. Indicates the string end."
            ],
            "guid": "i3dJk{</1W",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is a C-style string literal a literal or an object?",
                "It's an object - a static array of <code>const char</code> stored in read-only memory, created at program start."
            ],
            "guid": "or#)F$0,R=",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Strings", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>constant folding</b>?",
                "A compiler optimization technique that evaluates expressions with literal operands at compile time and replaces them with the result."
            ],
            "guid": "GrL5tgp+3o",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Compile-Time", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>constant propagation</b>?",
                "A compiler optimization technique that replaces variables known to have constant values with those values."
            ],
            "guid": "uWniWu|3JU",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Compile-Time", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is dead code elimination?",
                "A compiler optimization that removes code that has no effect on the program's observable behavior (unreachable code or code with unused results)."
            ],
            "guid": "pjC&vFkWf,",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Optimization", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>compile-time constant</b>?",
                "A constant whose value is known at compile time, such as literals and constexpr objects."
            ],
            "guid": "E4_eyL=u3<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>runtime constant</b>?",
                "A constant whose value is determined at runtime, such as const function parameters and other non-compile-time constants."
            ],
            "guid": "sJdR(0rz@",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>constexpr variable</b>?",
                "A variable that requires an initializer that can be evaluated at compile time."
            ],
            "guid": "FYeEB>>Bz",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is a compile-time evaluatable expression required?",
                "<ul><li>constexpr variable initializers</li><li>Non-type template arguments</li><li>C-style array lengths</li></ul>"
            ],
            "guid": "OgD:j?hK9I",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>compile-time programming</b>?",
                "The use of language features (like constexpr, templates, static_assert) that enable evaluation at compile time."
            ],
            "guid": "M-$L/=Fcmp",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Compile-Time", "Metaprogramming"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the key benefits of compile-time programming?",
                "Improved performance (no runtime overhead) and higher code quality (errors caught at compile time)."
            ],
            "guid": "kL^#m4dG`X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Compile-Time", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the key C++ features for compile-time programming?",
                "<ol><li><code>constexpr</code> variables and functions</li><li>Templates</li><li><code>static_assert</code></li></ol>"
            ],
            "guid": "w[{%d,De$R",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Compile-Time", "Metaprogramming"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a <b>runtime expression</b>?",
                "A non-constant expression that cannot be evaluated at compile time."
            ],
            "guid": "CYmz<yHV;3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is <code>const double c { 5.0 };</code> a compile-time constant?",
                "No, <code>c</code> is not a compile-time constant because <code>double</code> is not an integral type (only const integrals are compile-time constants)."
            ],
            "guid": "Q@Vuv6O)tk",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const", "Constexpr"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between const and constexpr?",
                "<code>const</code>: Value cannot be modified after initialization (but may be runtime or compile-time).<br><code>constexpr</code>: Value must be computable at compile time. Implies const."
            ],
            "guid": ",!=1K}N(-",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Const", "Constexpr"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you read a full line of input into a string?",
                "<code>std::getline(std::cin, str)</code> - reads until newline, discards the newline."
            ],
            "guid": "mT,-5F)g+O",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "IO", "Strings"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it efficient to return <code>std::string</code> by value?",
                "Yes, due to copy elision (NRVO) and move semantics. The compiler optimizes away copies when returning local strings or temporaries."
            ],
            "guid": "sP+Vc,l^-k",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Strings", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a compound statement (block)?",
                "A group of zero or more statements enclosed in braces <code>{ }</code>, treated as a single statement. Creates a new scope."
            ],
            "guid": "JKgcu6g=7P",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Basics", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a user-defined namespace?",
                "A namespace created by the programmer using the <code>namespace</code> keyword to organize code and prevent name collisions."
            ],
            "guid": "y$Q<z7]u>c",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Namespaces"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is storage duration?",
                "The property that determines when a variable is created and destroyed. Types: automatic, static, dynamic, thread-local."
            ],
            "guid": "Gq^U%5b67!",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Memory", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are global variables?",
                "Variables declared at file scope (outside any function), typically with static storage duration."
            ],
            "guid": "r&/Hr^alY3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Variables", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are namespace-scope variables global variables?",
                "Not exactly. They have static storage duration but are not in the global namespace. True global variables are those declared at namespace scope in the global (unnamed) namespace."
            ],
            "guid": "4KW{%zL}K",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Namespaces", "Variables", "Storage-Duration"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are global variables initialized?",
                "Zero-initialized by default (before any explicit initialization). Non-local variables with constexpr initializers are constant-initialized."
            ],
            "guid": "pc0V]B<G>~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is name hiding (shadowing)?",
                "When an inner-scope variable has the same name as an outer-scope variable, hiding access to the outer variable within that scope."
            ],
            "guid": "F[>,S?v>Ib",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Scope"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is internal linkage?",
                "An identifier can only be seen and used within a single translation unit. Declared with <code>static</code> keyword at file scope."
            ],
            "guid": "jQe(dnA]v4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is external linkage?",
                "An identifier can be accessed from other translation units via forward declaration. Functions and non-const globals have external linkage by default."
            ],
            "guid": "f7c3Sze}Q3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the default linkage of functions?",
                "External linkage - functions can be called from other translation units."
            ],
            "guid": "HH<+X{=$X+",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which global variables have external linkage by default?",
                "Non-const global variables. Const globals have internal linkage by default."
            ],
            "guid": "op.-i[NTH{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does the <code>extern</code> keyword do?",
                "Declares a variable/function with external linkage without defining it. Used for forward declarations across translation units."
            ],
            "guid": "Be5elkc}i!",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Declarations"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between scope, duration, and linkage?",
                "<b>Scope</b>: Where a variable is accessible<br><b>Duration</b>: When it's created/destroyed<br><b>Linkage</b>: Whether it can be accessed from other translation units"
            ],
            "guid": "BkPzxL50H]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Linkage"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What scope, duration, and linkage do global variables have?",
                "File/global scope, static duration, and either internal linkage (<code>static</code>) or external linkage (<code>extern</code> or non-const by default)."
            ],
            "guid": "dI7MLB-<O7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Linkage"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When are static variables initialized?",
                "Before <code>main()</code> executes. Zero-initialized first, then constant/dynamic initialization occurs."
            ],
            "guid": "zs0IMhj+On",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Initialization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is overhead?",
                "The extra work required to set up, facilitate, and clean up after a task (e.g., function call overhead includes pushing/popping stack frames)."
            ],
            "guid": "ExtHSyORJ*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Performance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is inline expansion (inlining)?",
                "A compiler optimization where a function call is replaced with the function's body, eliminating call overhead."
            ],
            "guid": "A}Eg^lUEbb",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Optimization", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the default linkage of constexpr variables?",
                "Internal linkage (like const). Use <code>inline constexpr</code> for external linkage in headers."
            ],
            "guid": "h6u{8uvngw",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Constexpr", "Linkage"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What effect does <code>static</code> have on a global variable?",
                "Gives it internal linkage - the variable is only visible within its translation unit and cannot be accessed from other files."
            ],
            "guid": "xl`^WoDze[",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Linkage", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What effect does <code>static</code> have on a local variable?",
                "Gives it static storage duration - initialized once on first use and persists until program end, retaining its value between function calls."
            ],
            "guid": "DWREt_Yj2q",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the storage class specifiers in C++?",
                "1. <code>extern</code> - external linkage<br>2. <code>static</code> - internal linkage (global) or static duration (local)<br>3. <code>thread_local</code> - thread storage duration<br>4. <code>mutable</code> - allows modification in const context"
            ],
            "guid": "oA4X+h-iF#",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Variables", "Linkage"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a qualified name?",
                "A name that includes its scope using the scope resolution operator, e.g., <code>std::vector</code>, <code>MyClass::method</code>."
            ],
            "guid": "pq.F]T-4Xd",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Namespaces", "Scope"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the scope resolution operator?",
                "<code>::</code> - used to access members of a namespace, class, or the global scope."
            ],
            "guid": "g;@wvW-6l`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "Scope"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an unqualified name?",
                "A name without scope qualification - just the identifier itself, e.g., <code>vector</code> instead of <code>std::vector</code>."
            ],
            "guid": "f*J-l0%K8^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Namespaces", "Scope"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an anonymous (unnamed) namespace?",
                "A namespace without a name. Contents have internal linkage and are only accessible within the same translation unit. Preferred over <code>static</code> for file-local scope."
            ],
            "guid": "xo!+?t~y=:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Namespaces", "Linkage"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is scope creep?",
                "Adding new capabilities to a project that were not originally planned, often leading to project delays and complexity."
            ],
            "guid": "m2i^^g.&~_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is software testing?",
                "The process of verifying that software works as expected, including finding bugs and ensuring requirements are met."
            ],
            "guid": "q8_AXjMfEI",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Testing"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is code coverage?",
                "A metric measuring what percentage of source code is executed during testing (statement coverage, branch coverage, etc.)."
            ],
            "guid": "idT_*Hx`JY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Testing"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the main code coverage strategies?",
                "Statement coverage (every line executed), branch coverage (every if/else path taken), loop coverage (0, 1, and multiple iterations)."
            ],
            "guid": "ff#f3:MSW`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Testing"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are common types of semantic (logic) errors?",
                "Off-by-one errors, infinite loops, wrong operator precedence, using assignment instead of equality, integer division issues, forgetting braces for compound statements."
            ],
            "guid": "vi8}xmOc%r",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Debugging", "Errors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the main types of object relationships in OOP?",
                "1. Composition (owns)<br>2. Aggregation (has-a, shared ownership)<br>3. Association (uses)<br>4. Dependency (temporary use)<br>5. Inheritance (is-a)"
            ],
            "guid": "B*pJgnp$v>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is object composition?",
                "Building complex objects from simpler objects, where the parts don't exist independently of the whole. The container manages the lifetime of its parts."
            ],
            "guid": "g7{y$uo?<>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the two types of object composition?",
                "<b>Composition</b>: Part cannot exist independently, exclusive ownership.<br><b>Aggregation</b>: Part can exist independently, shared ownership possible."
            ],
            "guid": "o`TC1bHjc2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the properties of composition?",
                "1. Part belongs to exactly one object<br>2. Object manages part's lifetime (creates/destroys)<br>3. Part doesn't know about the whole<br>4. Usually implemented as member variables"
            ],
            "guid": "bRVPk9x+ad",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between composition and aggregation?",
                "<b>Composition</b>: Object owns and manages part's lifetime (value member).<br><b>Aggregation</b>: Object doesn't own part; uses pointer/reference. Part exists independently."
            ],
            "guid": "tA~K~GitNq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the properties of aggregation?",
                "1. Part can belong to multiple objects<br>2. Object doesn't manage part's lifetime<br>3. Part doesn't know about the whole<br>4. Usually implemented via pointers/references"
            ],
            "guid": "FPncX3xrMT",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you store an array of references?",
                "You cannot - references aren't rebindable. Use <code>std::reference_wrapper&lt;T&gt;</code> instead, which can be stored in containers."
            ],
            "guid": "KS8rK-o;B`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the properties of association?",
                "1. Objects are otherwise unrelated<br>2. Can be bidirectional (each knows about the other)<br>3. Neither manages the other's lifetime<br>4. Looser coupling than aggregation"
            ],
            "guid": "Ay4l%d3gxp",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is reflexive association?",
                "An association between objects of the same type. Examples: a university course and its prerequisites (also courses), or nodes in a binary tree pointing to other nodes."
            ],
            "guid": "Q7<d}-W}7B",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Association"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the relationship verbs for composition, aggregation, association, dependency, and inheritance?",
                "<b>part-of</b> → composition<br><b>has-a</b> → aggregation<br><b>uses-a</b> → association<br><b>depends-on</b> → dependency<br><b>is-a</b> → inheritance"
            ],
            "guid": "u&za^&Q]&M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Object-Relationships"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which object relationships are unidirectional and which are bidirectional?",
                "<b>Unidirectional:</b> composition, aggregation, dependency, inheritance<br><b>Bidirectional:</b> association (both objects can know about each other)"
            ],
            "guid": "rY~po<on:W",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Object-Relationships"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a dependency relationship?",
                "When one object needs to invoke another object's functionality to accomplish a specific task, typically by receiving it as a parameter rather than storing it as a member."
            ],
            "guid": "Ebl{[p;$Y0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Dependency"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between dependency and association?",
                "Dependencies are typically passed as function parameters (temporary usage), while associations are stored as member variables (longer relationship)."
            ],
            "guid": "PXkX/l@QIM",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Object-Relationships"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a container class?",
                "A class designed to hold and organize multiple instances of another type, such as <code>std::vector</code>, <code>std::map</code>, or <code>std::array</code>."
            ],
            "guid": "CzI.6>K6)g",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are value containers vs reference containers?",
                "<b>Value containers</b> store copies (composition - they own the elements).<br><b>Reference containers</b> store pointers/references (aggregation - elements exist independently)."
            ],
            "guid": "cu72hR-0z%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Containers", "Object-Relationships"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a parent class (base class / superclass)?",
                "The class being inherited from. It provides members and behavior that derived classes can reuse or override."
            ],
            "guid": "nBcNz?*+*B",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a child class (derived class / subclass)?",
                "The class that inherits from another. It receives the base class members and can add new ones or override existing behavior."
            ],
            "guid": "n]3j*$?3nc",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the order of construction in a class hierarchy?",
                "1. Memory for entire object is allocated<br>2. Derived class constructor is called<br>3. Base class constructor runs first (recursively up the chain)<br>4. Member initializer list initializes members<br>5. Constructor body executes<br>6. Then derived portions complete in order"
            ],
            "guid": "lMWvjnal4]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Constructors"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the default inheritance type for classes vs structs?",
                "<code>struct</code> defaults to <b>public</b> inheritance.<br><code>class</code> defaults to <b>private</b> inheritance."
            ],
            "guid": "c7qEC^&zr,",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does public inheritance mean?",
                "Base <code>public</code> → stays <code>public</code><br>Base <code>protected</code> → stays <code>protected</code><br>Base <code>private</code> → inaccessible<br><br>Protected members are accessible in derived classes but not from outside."
            ],
            "guid": "sVd#IaF:CW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does protected inheritance mean?",
                "Base <code>public</code> → becomes <code>protected</code><br>Base <code>protected</code> → stays <code>protected</code><br>Base <code>private</code> → inaccessible<br><br>Extremely rare in practice. Public interface of base becomes protected in derived."
            ],
            "guid": "OuC[KiLg`0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does private inheritance mean?",
                "Base <code>public</code> → becomes <code>private</code><br>Base <code>protected</code> → becomes <code>private</code><br>Base <code>private</code> → inaccessible<br><br>Members are accessible within the derived class but not from outside or further derived classes."
            ],
            "guid": "q@UsE4wn[A",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does the compiler decide which function to call in a non-polymorphic hierarchy?",
                "It finds the best match starting from the most-derived class and working up. Name lookup stops at the first scope where a matching name is found."
            ],
            "guid": "H@0=.]|sft",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you call a base class friend function when scope resolution doesn't work?",
                "Use <code>static_cast</code> to cast the object to the base type. Friend functions are not members, so <code>Base::func()</code> syntax doesn't work for them."
            ],
            "guid": "1FIZ*uAW:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you bring a base class function into the derived class scope?",
                "Use a <b>using-declaration</b>:<br><pre><code class=\"language-cpp\">class Derived : public Base {\n    using Base::someFunction;\n};</code></pre>"
            ],
            "guid": "N|$3#>`Mri",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the side effects of using-declarations in class definitions?",
                "They can change access levels: protected members become public, or public members become private, depending on which access section contains the using-declaration."
            ],
            "guid": "D~G`54psp>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens to all overloads when using a using-declaration inside a class?",
                "All overloads of the named function are brought in with the access level of the using-declaration's location, not their original access levels."
            ],
            "guid": "xDjxDfV%j9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is access control in C++ enforced at runtime or compile-time?",
                "<b>Compile-time.</b> Access violations are detected during compilation, not at runtime."
            ],
            "guid": "JM8S4m*Njd",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Access-Specifiers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does C++ support multiple inheritance?",
                "Yes. A class can inherit from multiple base classes:<br><pre><code class=\"language-cpp\">class Derived : public Base1, public Base2 { };</code></pre>"
            ],
            "guid": "t#]3fS92ab",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a mixin?",
                "A small class designed to be inherited from to add specific properties or behavior to another class. Mixins are intended to be mixed into other classes, not instantiated on their own."
            ],
            "guid": "uLy>kT6*:D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Design-Patterns"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is CRTP?",
                "<b>Curiously Recurring Template Pattern</b> - a derived class inherits from a base class template parameterized by the derived class itself:<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nclass Base { };\nclass Derived : public Base&lt;Derived&gt; { };</code></pre>"
            ],
            "guid": "vj;ZXzgZOj",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Design-Patterns", "Metaprogramming"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the diamond problem?",
                "When a class inherits from two classes that share a common base, creating ambiguity about which copy of the base class members to use. Solved with <b>virtual inheritance</b>."
            ],
            "guid": "q{ujC||h_X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In what order are local variables destroyed?",
                "In <b>reverse order</b> of their construction (LIFO - last constructed is first destroyed)."
            ],
            "guid": "mS`mHcl;NU",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Memory", "Variables"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you create a pointer to a class member variable?",
                "<pre><code class=\"language-cpp\">int Car::*pColor = &amp;Car::color;\nCar a;\nint val = a.*pColor;  // Access via object</code></pre>"
            ],
            "guid": "DR?4Z4kWxb",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Pointers", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you create a pointer to a member function?",
                "<pre><code class=\"language-cpp\">void (S::*pFunc)(int) = &amp;S::print;\nS s;\n(s.*pFunc)(2);  // Call via object</code></pre>"
            ],
            "guid": "y`#[An<eF}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Pointers", "OOP", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is the friend relationship inherited by derived classes?",
                "<b>No.</b> Friendship is not transitive or inheritable. A friend of a base class is not automatically a friend of derived classes."
            ],
            "guid": "zKDa$TH4s`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a PRNG?",
                "<b>Pseudo-Random Number Generator</b> - an algorithm that generates a sequence of numbers that approximate the properties of random numbers. Examples: <code>std::mt19937</code>, <code>std::minstd_rand</code>."
            ],
            "guid": "qc:!}rU`fW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Algorithms", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a random seed?",
                "The value (or set of values) used to initialize the starting state of a PRNG. The same seed always produces the same sequence of numbers."
            ],
            "guid": "vo!PERl1&M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Algorithms", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean for a PRNG to be underseeded?",
                "The PRNG was not provided with enough bits of quality randomness in the seed, making its output more predictable or limited in range."
            ],
            "guid": "hOpg_N0**>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Algorithms", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are ideal seed characteristics for a PRNG?",
                "1. Contains at least as many bits as the PRNG state<br>2. Each bit is independently randomized<br>3. Good mix of 0s and 1s distributed across all bits<br>4. No bits always the same value<br>5. Low correlation with previously generated seeds"
            ],
            "guid": "N;Vrs12ypG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are ideal characteristics of a PRNG?",
                "1. <b>Distribution uniformity</b> - each number equally probable<br>2. <b>Unpredictability</b> - next number shouldn't be predictable<br>3. <b>Dimensional distribution</b> - numbers well-distributed in N-dimensional space<br>4. <b>High period</b> - long sequence before repeating<br>5. <b>Efficiency</b> - fast generation"
            ],
            "guid": "va*zbA]spz",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the period of a PRNG?",
                "The length of the sequence before a PRNG begins to repeat itself. <code>std::mt19937</code> has a period of 2<sup>19937</sup>-1."
            ],
            "guid": "x.y1^L/^}5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Algorithms", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the PRNG tools in C++?",
                "The <code>&lt;random&gt;</code> header provides 6 PRNG families. <code>std::mt19937</code> (Mersenne Twister) is the recommended one for most purposes - it has excellent statistical properties and a huge period."
            ],
            "guid": "LgScM5nl&.",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "STL", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do random number distributions help with PRNGs?",
                "They convert the uniform output of a PRNG into other distributions. Example: <code>std::normal_distribution</code>, <code>std::uniform_int_distribution</code>."
            ],
            "guid": "syd(x>=UX:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "STL", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is std::random_device?",
                "An implementation-defined random number generator that attempts to use true hardware randomness from the OS. Used to seed other PRNGs, but may be slow or unavailable on some systems."
            ],
            "guid": "j{iP`f=nVK",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "STL", "Algorithms"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the steps to compile a C++ program?",
                "1. <b>Preprocessing</b> - handle #include, #define, etc.<br>2. <b>Compilation</b> - translate to assembly (.s)<br>3. <b>Assembly</b> - translate to machine code (.o)<br>4. <b>Linking</b> - combine object files into executable (.out/.exe)"
            ],
            "guid": "zb[{|+EB|J",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Compilation"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What g++ flags stop at specific compilation stages?",
                "<code>g++ -E</code> - stop after preprocessing<br><code>g++ -S</code> - stop after compilation (assembly output)<br><code>g++ -c</code> - stop after assembly (object file output)"
            ],
            "guid": "lNxmy)EhR<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Compilation"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the common sanitizer types in C++?",
                "<b>AddressSanitizer</b> - detects memory errors (buffer overflow, use-after-free)<br><b>LeakSanitizer</b> - detects memory leaks<br><b>UndefinedBehaviorSanitizer</b> - detects undefined behavior"
            ],
            "guid": "Kuj1Rzwsa6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Debugging", "Compilation"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which operators cannot be overloaded?",
                "1. <code>?:</code> (conditional)<br>2. <code>sizeof</code>, <code>typeid</code><br>3. <code>::</code> (scope resolution)<br>4. <code>.</code> and <code>.*</code> (member selection)<br>5. C-style casts"
            ],
            "guid": "QsX/pPDOHG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is it possible to create your own operators in C++?",
                "<b>No.</b> You can only overload existing operators, not create new ones."
            ],
            "guid": "Btb.]zmPy]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Operators", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you overload operators for built-in types like int and double?",
                "<b>No.</b> At least one operand must be a user-defined type. You cannot change how <code>int + double</code> works."
            ],
            "guid": "K=Kz5ytfD2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you change operator precedence or associativity when overloading?",
                "<b>No.</b> Precedence and associativity are fixed by the language. Overloading only changes what the operator does, not when it's applied."
            ],
            "guid": "upS6YLm[Sv",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the three ways to overload an operator?",
                "1. As a <b>member function</b> (left operand is <code>this</code>)<br>2. As a <b>friend function</b> (access to privates)<br>3. As a <b>normal function</b> (no special access)"
            ],
            "guid": "vw&ZnYNm^4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you define a friend function inside the class that declares it?",
                "Yes. The function is defined inline but remains a non-member function - it just has access to private members."
            ],
            "guid": "M|th8~@sOW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the limitation of non-const reference parameters?",
                "Non-const lvalue references cannot bind to rvalues (temporaries). Use <code>const&amp;</code> to accept both lvalues and rvalues, or use rvalue references for move semantics."
            ],
            "guid": "uVI?`ClKaY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "References", "Functions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean for an operation to be transactional?",
                "It either succeeds completely or fails completely with no partial effects. No intermediate state is visible - important for exception safety and data consistency."
            ],
            "guid": "GD,Cu7e_d%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Best-Practices", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which operators must be implemented as member functions?",
                "1. <code>=</code> (assignment)<br>2. <code>[]</code> (subscript)<br>3. <code>()</code> (function call)<br>4. <code>-&gt;</code> (member access)"
            ],
            "guid": "BWQ2.i3A^X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When should you use member, friend, or normal function for operator overloading?",
                "1. <b>Member-only operators</b> (=, [], (), ->) → member<br>2. <b>Unary operators</b> → member<br>3. <b>Binary that don't modify left operand</b> → friend/normal<br>4. <b>Binary that modify left operand</b> → member"
            ],
            "guid": "u;R}H{Q%P`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Operators", "OOP", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the copy-and-swap idiom?",
                "A technique for implementing exception-safe assignment operators: make a copy of the parameter, then swap contents with the copy. The old data is automatically destroyed when the copy goes out of scope."
            ],
            "guid": "FwJ<SdJu=g",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Copy-Semantics", "Best-Practices", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a shallow copy?",
                "A memberwise copy where pointers are copied by value. Both objects end up pointing to the same dynamically allocated memory, leading to double-delete problems."
            ],
            "guid": "oPRb5/)T|j",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Copy-Semantics", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a deep copy?",
                "A copy that allocates new memory and copies the actual data, not just the pointers. The copy is completely independent of the source object."
            ],
            "guid": "ei+F1Gu,`z",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Copy-Semantics", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are virtual functions?",
                "Member functions that resolve to the most-derived version based on the actual runtime type of the object, not the static type of the pointer/reference."
            ],
            "guid": "jSS3rXRy6A",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Polymorphism", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why are virtual functions needed?",
                "Without them, calling a function through a base class pointer/reference only considers base class functions. Virtual functions enable calling the correct derived class override based on actual object type."
            ],
            "guid": "n[j^Iv|ao7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Polymorphism", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are virtual tables (vtables) implemented?",
                "Each class with virtual functions has a static vtable containing pointers to the most-derived versions of each virtual function. Each object has a hidden <code>__vptr</code> member pointing to its class's vtable, set at construction time."
            ],
            "guid": "Jd3i4.rDoJ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Polymorphism", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is polymorphism?",
                "The ability of entities (functions, objects) to take on multiple forms. In C++: function overloading, templates (compile-time), and virtual functions (runtime)."
            ],
            "guid": "xU~4r;iVvD",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Polymorphism"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is compile-time polymorphism?",
                "Polymorphism resolved by the compiler: <b>function overloading</b>, <b>template instantiation</b>, and <b>operator overloading</b>. Also called static polymorphism."
            ],
            "guid": "KkT|an{Swb",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Polymorphism", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is runtime polymorphism?",
                "Polymorphism resolved at runtime through <b>virtual function dispatch</b>. The actual function called depends on the dynamic type of the object, determined via the vtable."
            ],
            "guid": "B+RVU)$Bpc",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Polymorphism", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Should you call virtual functions from constructors or destructors?",
                "<b>No.</b> During construction/destruction, the object is in a partially formed state. Virtual calls resolve to the current class's version, not derived overrides - the vtable doesn't point to derived implementations yet."
            ],
            "guid": "h9`2ws~+Q*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual", "Constructors", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does the return type matter when overriding virtual functions?",
                "Yes, generally return types must match exactly. The exception is <b>covariant return types</b>: you can return a pointer/reference to a more derived type."
            ],
            "guid": "cVz3_*5myq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the performance costs of virtual functions?",
                "1. <b>vtable per class</b> - memory for function pointer array<br>2. <b>vptr per object</b> - typically 8 bytes on 64-bit<br>3. <b>Indirect call</b> - pointer lookup prevents inlining and branch prediction"
            ],
            "guid": "f`N4$5lRP^",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the override specifier?",
                "Added after a function signature to indicate intent to override a base class virtual function. The compiler verifies a matching virtual function exists, catching typos and signature mismatches."
            ],
            "guid": "FB]}1+tB3F",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Virtual", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the final specifier?",
                "Prevents further overriding of a virtual function or inheritance from a class. Can help compiler devirtualize calls."
            ],
            "guid": "wHo+t&=Guf",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Virtual", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are covariant return types?",
                "An exception allowing virtual function overrides to return a pointer/reference to a more derived type than the base version. Example: <code>Base* clone()</code> overridden as <code>Derived* clone()</code>."
            ],
            "guid": "Fy(Pn%<>/h",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you bypass virtual dispatch and call a specific base class version?",
                "Use the scope resolution operator: <code>obj.Base::virtualFunc()</code>. This calls the base class version directly without vtable lookup."
            ],
            "guid": "O@-vW~JUv:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is binding in programming?",
                "The process of associating names (identifiers) with their definitions or properties. For functions, it determines which implementation a call refers to."
            ],
            "guid": "lX)v^B3kh]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Polymorphism"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is function binding?",
                "The process of associating a function call with a specific function definition. Invoking a bound function is called <b>dispatching</b>."
            ],
            "guid": "t~wpCCyO$M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Functions", "Polymorphism"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is early (static) binding?",
                "Binding performed at compile-time. Used for direct function calls, non-virtual member functions, and statically resolved function pointers. The compiler knows exactly which function to call."
            ],
            "guid": "tHMs#O&2Qq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Polymorphism", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is late (dynamic) binding?",
                "Binding resolved at runtime. Used for virtual function calls where the actual function depends on the runtime type of the object, not the compile-time type of the pointer/reference."
            ],
            "guid": "m^dFL1e)6$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Polymorphism", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a virtual table (vtable)?",
                "A lookup table of function pointers used to resolve virtual function calls at runtime. Each class with virtual functions has one vtable, and each object has a hidden pointer to its class's vtable."
            ],
            "guid": "vpCbI<(Ni)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual", "Polymorphism"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a pure virtual function?",
                "A virtual function with no implementation, declared as <code>= 0</code>. Derived classes must override it (unless they're also abstract).<br><pre><code class=\"language-cpp\">virtual void func() = 0;</code></pre>"
            ],
            "guid": "v1jz{W_d@5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the consequences of having a pure virtual function?",
                "The class becomes <b>abstract</b>: you cannot instantiate it directly. Only concrete derived classes that override all pure virtual functions can be instantiated."
            ],
            "guid": "L1^4x$u5L`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is an interface class?",
                "An abstract class with no member variables and only pure virtual functions. Defines a contract that implementing classes must fulfill."
            ],
            "guid": "LV;mE19AZ)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual", "Design-Patterns"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does an abstract class have a vtable?",
                "Yes. It needs one to resolve virtual destructor calls and any non-pure virtual functions. Pure virtual function entries may point to a stub that terminates if called."
            ],
            "guid": "C?ozuZ&P4]",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a virtual base class?",
                "A solution to the diamond problem. Declare inheritance as <code>virtual</code> to ensure only one copy of the base class is shared. The most-derived class is responsible for constructing the virtual base."
            ],
            "guid": "wo@i$Ug/~F",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is object slicing?",
                "When a derived class object is copied into a base class variable, the derived-specific parts are \"sliced off\" and lost. Only the base class portion remains."
            ],
            "guid": "l}`34~F4i*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Copy-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In what situations can object slicing occur?",
                "1. Passing by value instead of by reference/pointer<br>2. Storing objects in containers by value (use pointers or <code>std::reference_wrapper</code>)<br>3. Assigning derived to base when assignment isn't virtual"
            ],
            "guid": "Gem&=q$D{<",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is upcasting?",
                "Converting a pointer/reference to a derived class to a pointer/reference to a base class. Done implicitly and is always safe (every Derived <i>is-a</i> Base)."
            ],
            "guid": "q],w9$*7W0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is downcasting?",
                "Converting a pointer/reference from base class to derived class. Use <code>dynamic_cast</code> for safety (runtime check) or <code>static_cast</code> if you're certain of the type (no check, undefined behavior if wrong)."
            ],
            "guid": "fK_O}qeV>",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Inheritance", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens when dynamic_cast fails on a pointer?",
                "It returns <code>nullptr</code>. Always check the result before using it."
            ],
            "guid": "fx@+Re3sq5",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion", "Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can dynamic_cast be used with references?",
                "Yes, but on failure it throws <code>std::bad_cast</code> instead of returning nullptr (since references can't be null)."
            ],
            "guid": "GtH>=^&}bf",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Conversion", "References", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is EBO (Empty Base Optimization)?",
                "An optimization where an empty base class takes no space in the derived object's layout. Empty classes normally have size 1 for unique addresses, but as a base class they can be optimized to size 0."
            ],
            "guid": "PE*4?Q8VRN",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Inheritance", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "In a diamond inheritance (Son from Mom and Dad, both from Granny with int member), what's the size of Son?",
                "Without virtual inheritance: ~40 bytes (two Granny copies + two vptrs + padding). With virtual inheritance: ~32 bytes (one shared Granny)."
            ],
            "guid": "HJblfP*bM~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Inheritance", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if only one path in a diamond uses virtual inheritance?",
                "You get two copies of the base: one shared virtual instance and one non-virtual instance. This is usually unintended and confusing."
            ],
            "guid": "NE$ykSDVB6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "OOP", "Inheritance", "Virtual"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is RTTI?",
                "<b>Runtime Type Information</b> - allows querying object types at runtime. Enables <code>dynamic_cast</code> and <code>typeid</code>. Requires at least one virtual function."
            ],
            "guid": "D8|Izm<@v7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Polymorphism", "Type-Conversion"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the minimum size of an empty class with a virtual function?",
                "At least 8 bytes (on 64-bit systems) for the vptr - the hidden pointer to the vtable."
            ],
            "guid": "jR8}|C_x#_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "OOP", "Virtual", "Memory"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a container (in C++)?",
                "A data structure that stores and organizes a collection of elements. STL containers include <code>vector</code>, <code>map</code>, <code>set</code>, <code>list</code>, <code>deque</code>, etc."
            ],
            "guid": "HKT{i*O.Go",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean for a container to be homogeneous?",
                "All elements must have the same type. Most C++ STL containers are homogeneous (e.g., <code>vector&lt;int&gt;</code>). Use <code>std::variant</code> or <code>std::any</code> for heterogeneous storage."
            ],
            "guid": "iS~mc!MT1f",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean for a container to be heterogeneous?",
                "Elements can be of different types. Traditional STL containers don't support this, but C++17 added <code>std::variant</code> and <code>std::any</code> for type-erased heterogeneous storage."
            ],
            "guid": "fa/{5z2OvG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What's the difference between <code>vector&lt;int&gt; v1{5}</code> and <code>vector&lt;int&gt; v2(5)</code>?",
                "<code>{5}</code> creates a vector with one element (value 5).<br><code>(5)</code> creates a vector with 5 default-initialized elements (all zeros for int)."
            ],
            "guid": "nkbz8|Y0XG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Containers", "Initialization", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is size_type in STL containers?",
                "A nested typedef that's an unsigned integer type suitable for representing container sizes and indices. Typically an alias for <code>std::size_t</code>."
            ],
            "guid": "davc+.`Z$U",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What type does size_type typically resolve to?",
                "<code>std::size_t</code>, which is an <b>unsigned</b> integer type. Be careful mixing it with signed integers to avoid signed/unsigned comparison warnings."
            ],
            "guid": "xn1!/l6b)o",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL", "Types"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What functions return size_type?",
                "Container's <code>.size()</code> member function and <code>std::size()</code> (C++17) both return <code>size_type</code>. Use <code>std::ssize()</code> (C++20) for signed result."
            ],
            "guid": "d3(v}mahvp",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is copy semantics?",
                "The rules determining how object copies are made. Involves the copy constructor and copy assignment operator. Results in two independent objects with the same data."
            ],
            "guid": "h5[2d91X+v",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Copy-Semantics", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does it mean when ownership of data is transferred from one object to another?",
                "The data has been <b>moved</b>. The source object is left in a valid but unspecified state (often empty or null)."
            ],
            "guid": "BYs4..*XJC",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is move semantics?",
                "Rules for transferring ownership of resources from one object to another efficiently. Requires:<br>1. Type supports move (has move constructor/assignment)<br>2. Object initialized with rvalue<br>3. Move isn't elided by the compiler"
            ],
            "guid": "vtv3B@vCr?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens when you move an object that doesn't support move semantics?",
                "It falls back to <b>copying</b>. Move semantics are optional - if not provided, the copy constructor/assignment is used instead."
            ],
            "guid": "N=>3C2jUIx",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Move-Semantics", "Copy-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What's the difference between length (size) and capacity in std::vector?",
                "<b>Size</b>: number of elements currently stored.<br><b>Capacity</b>: number of elements that can be stored before reallocation. Capacity >= size."
            ],
            "guid": "f}C72i}P^$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why does std::vector track capacity separately from size?",
                "To avoid frequent reallocations. When capacity exceeds size, <code>push_back</code> doesn't need to allocate new memory - it just uses existing capacity."
            ],
            "guid": "JShau,kKv4",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Containers", "STL", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are valid indices for std::vector based on size or capacity?",
                "<b>Size (length)</b>. Indices 0 to size-1 are valid. Accessing beyond size (even within capacity) is undefined behavior."
            ],
            "guid": "H>GWyb];RO",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Containers", "STL", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is special about std::vector<bool>?",
                "A space-optimized specialization that stores bits, not actual bools. It doesn't satisfy standard container requirements - <code>operator[]</code> returns a proxy, not a reference. Prefer <code>std::bitset</code> or <code>std::deque&lt;bool&gt;</code>."
            ],
            "guid": "dJ57z)oORG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Containers", "STL", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is undefined behavior?",
                "Program behavior where the C++ standard imposes no requirements. Anything can happen: crash, wrong results, or seemingly correct behavior. Common causes: null dereference, buffer overflow, use after free."
            ],
            "guid": "no]9?,MpR+",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Undefined-Behavior"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are references preserved during template type deduction?",
                "<b>No</b> - reference-ness is stripped unless the parameter is itself a reference. <code>int&amp;</code> and <code>int</code> arguments both deduce <code>T = int</code> for <code>f(T)</code>."
            ],
            "guid": "tWhqe05{F[",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens to <code>const</code> and <code>volatile</code> qualifiers in by-value parameters during template deduction?",
                "Top-level <code>const</code> and <code>volatile</code> are ignored."
            ],
            "guid": "F5Q9Qe{&HG",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Do arrays and functions decay during template argument deduction?",
                "Yes — unless bound to a reference parameter, they decay to pointers."
            ],
            "guid": "qj^2<[JB%0",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the three fundamental template parameter forms for type deduction?",
                "1. Reference or pointer (<code>T&amp;</code>, <code>const T&amp;</code>, <code>T*</code>)<br>2. Forwarding reference (<code>T&amp;&amp;</code>)<br>3. By-value (<code>T</code>)"
            ],
            "guid": "O[;QuhJ0eS",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(const T&amp; param);\n\nint x = 0;\nf(x);</code></pre>",
                "<code>T = int</code>, parameter type = <code>const int&amp;</code>."
            ],
            "guid": "D)z)SI/mRv",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T* p);\n\nconst int* ptr = nullptr;\nf(ptr);</code></pre>",
                "<code>T = const int</code>, parameter type = <code>const int*</code>."
            ],
            "guid": "ra3{P%(M4?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nint x = 0;\nf(x);</code></pre>",
                "<code>T = int&amp;</code>, parameter type = <code>int&amp;</code> (reference collapsing)."
            ],
            "guid": "jQ/hS2=_%/",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T&amp;&amp; param);\n\nf(10);</code></pre>",
                "<code>T = int</code>, parameter type = <code>int&amp;&amp;</code>."
            ],
            "guid": "s,8M>zpou{",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why are <code>T&amp;&amp;</code> parameters special during type deduction?",
                "Because they are forwarding references that can bind to both lvalues and rvalues. Reference collapsing rules apply."
            ],
            "guid": "BeL@fT$8*)",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T param);\n\nconst int cx = 10;\nf(cx);</code></pre>",
                "<code>T = int</code> (top-level <code>const</code> is ignored when passing by value)."
            ],
            "guid": "wM/(GwA}U?",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> and actual parameter type?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T param);\n\nint x = 0;\nconst int&amp; rx = x;\nf(rx);</code></pre>",
                "<code>T = int</code> (both reference and const are ignored when passing by value)."
            ],
            "guid": "ej)Pquv&[j",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> for this code?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T param);\n\nconst int* const p = nullptr;\nf(p);</code></pre>",
                "<code>T = const int*</code>. The pointer's top-level <code>const</code> is dropped, but the pointee's <code>const</code> is preserved."
            ],
            "guid": "sbVdD1c=-.",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> in this code?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T param);\n\nint arr[10];\nf(arr);</code></pre>",
                "<code>T = int*</code> (array decays to pointer)"
            ],
            "guid": "hgf:F;:^Ig",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is deduced <code>T</code> in this code?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nvoid f(T&amp; param);\n\nconst int b[10] = {};\nf(b);</code></pre>",
                "<code>T = const int[10]</code> (reference to an array, no decay)"
            ],
            "guid": "e:CC]JD8Z*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are attributes in C++?",
                "Metadata that hints to the compiler about code. Syntax: <code>[[attribute]]</code>. Examples: <code>[[nodiscard]]</code>, <code>[[deprecated]]</code>, <code>[[maybe_unused]]</code>, <code>[[fallthrough]]</code>."
            ],
            "guid": "c|/I?N>gNi",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Attributes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can <code>auto&amp;&amp;</code> bind to both lvalues and rvalues?",
                "Yes. <code>auto&amp;&amp;</code> is a <b>forwarding (universal) reference</b>. It deduces to lvalue reference for lvalues and rvalue reference for rvalues."
            ],
            "guid": "J9Z|sMjtla",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Auto", "References", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens with <code>auto</code> return type here?<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nauto g() {\n    if constexpr (std::is_same_v&lt;T, int&gt;)\n        return 0;\n    else\n        return 1u;\n}</code></pre>",
                "<code>if constexpr</code> is evaluated before <code>auto</code> type deduction, so only the active branch affects the return type."
            ],
            "guid": "DKV{A&8WR$",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Constexpr", "Templates", "Type-Deduction"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a trailing return type?",
                "A trailing return type is a C++ syntax (introduced in C++11) that places the function's return type **after** the parameter list, using the -&gt; symbol. It's especially useful when the return type depends on template parameters or function arguments that are only available after the parameter list is parsed.<br><br>// C++11, можно только auto, без auto&amp;<br>template&lt;typename T&gt;<br>auto move(T&amp;&amp; value) -&gt; std::remove_reference_t&lt;T&gt;&amp;&amp; {<br>&nbsp;&nbsp;&nbsp; retrun static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(value);<br>}<br><br>In C++20, you can often replace this pattern with _abbreviated templates_:<br><br>// C++20, эквивалентно template&lt;typename T&gt;<br>void f(auto&amp;&amp; x) {}"
            ],
            "guid": "u:P%sL#]M*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Functions", "Templates", "C++11"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Where can <code>auto</code> be used in C++?",
                "Variable declarations, function return types, function parameters (C++20), and non-type template parameters (<code>template&lt;auto N&gt;</code>)."
            ],
            "guid": "vzyZb@ajBq",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Auto"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>decltype</code>?",
                "An operator that inspects the declared type of an expression at compile time without evaluating it."
            ],
            "guid": "GuhZ%#W48M",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is decltype evaluated at compile time?",
                "Yes. <code>decltype</code> is a compile-time-only construct that determines the type without evaluating the expression."
            ],
            "guid": "cmbN{$0C$6",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype", "Compile-Time"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does <code>decltype</code> preserve <code>const</code> and reference qualifiers?",
                "Yes, it preserves <code>const</code>, <code>volatile</code>, and <code>&amp;</code>/<code>&amp;&amp;</code> qualifiers."
            ],
            "guid": "gns4le0#Rb",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can you see the type of a variable at compile time?",
                "Use an undefined template to trigger a compiler error:<br><pre><code class=\"language-cpp\">template&lt;typename T&gt; struct Debug;\nDebug&lt;decltype(x)&gt; dbg;  // Error shows T</code></pre>"
            ],
            "guid": "spwsg%[^zM",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Debugging"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does reference collapsing apply to <code>decltype</code>?",
                "Yes — the same reference-collapsing rules apply."
            ],
            "guid": "io~I]2_9xV",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Deduction", "Decltype", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does <code>decltype</code> evaluate its expression?",
                "No — it only inspects the type without evaluating."
            ],
            "guid": "KiGd1WYv;y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does decltype(f()) call the function f()?",
                "<b>No.</b> <code>decltype</code> never evaluates its expression - it only determines the type at compile time. The function is never called."
            ],
            "guid": "wT$:v1s~zI",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Will this compile?<br><code>decltype(throw 1)* p = &amp;x;</code>",
                "<b>No.</b> <code>throw</code> expressions have type <code>void</code>, and you can't form a pointer to <code>void</code> from an expression like this."
            ],
            "guid": "qTJV9H_)R2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Deduction", "Decltype", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does decltype behave differently for variable names vs. expressions?",
                "For a <b>named variable</b> (id-expression): <code>decltype(x)</code> gives the declared type.<br>For <b>other expressions</b>:<br>- lvalue → <code>T&amp;</code><br>- xvalue → <code>T&amp;&amp;</code><br>- prvalue → <code>T</code>"
            ],
            "guid": "pkP2,xK8f%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does <code>decltype</code> differ from <code>auto</code>?",
                "<code>auto</code> strips references and <code>const</code>, while <code>decltype</code> preserves them exactly."
            ],
            "guid": "cm;N~eDy!Y",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Decltype", "Auto"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between <code>decltype(x)</code> and <code>decltype((x))</code>?",
                "<code>decltype(x)</code> gives the <b>declared type</b> of <code>x</code>.<br><code>decltype((x))</code> treats <code>(x)</code> as an <b>lvalue expression</b>, so the result is always <code>T&amp;</code>.<br><pre><code class=\"language-cpp\">int x = 0;\ndecltype(x)   a;     // int\ndecltype((x)) b = x; // int&amp;</code></pre>"
            ],
            "guid": "i&Rk7F`@#}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the type of <code>decltype(*p)</code> if <code>p</code> is <code>int*</code>?",
                "<code>int&amp;</code> — dereferencing yields an lvalue."
            ],
            "guid": "bh8X$3Gr3;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Deduction", "Decltype"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the size of <code>std::shared_ptr</code>?",
                "Two pointers (2 words):<br>1. Pointer to the managed object<br>2. Pointer to the control block"
            ],
            "guid": "f^*-1Q%B5X",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>std::shared_ptr</code>?",
                "A smart pointer that shares ownership of an object via reference counting. The object is deleted when the last <code>shared_ptr</code> owning it is destroyed."
            ],
            "guid": "ORnXg/d`M`",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between <code>std::shared_ptr</code> and <code>std::unique_ptr</code>?",
                "<code>shared_ptr</code> allows shared ownership (multiple owners); <code>unique_ptr</code> has sole/exclusive ownership."
            ],
            "guid": "rxKjQ}]dl_",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if <code>shared_ptr</code> cycles exist?",
                "Memory leak occurs because the reference count never reaches zero. Use <code>weak_ptr</code> to break cycles."
            ],
            "guid": "s.$Rr+-U`G",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>std::make_shared</code>?",
                "A function that creates a <code>shared_ptr</code> by allocating both the control block and the object in a single allocation, improving efficiency."
            ],
            "guid": "&y0:pf(Q3",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is stored in a <code>shared_ptr</code> control block?",
                "<ul><li>Shared reference count</li><li>Weak reference count</li><li>Pointer to managed object (or object itself with <code>make_shared</code>)</li><li>Deleter</li><li>Allocator</li></ul>"
            ],
            "guid": "F3Mg)#zNwV",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is a <code>shared_ptr</code> control block deleted?",
                "When both the shared count and weak count reach zero."
            ],
            "guid": "w5%H*tPIDe",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why are two counters needed in <code>shared_ptr</code>?",
                "To allow <code>weak_ptr</code> to exist after the object is deleted. The weak count tracks how many <code>weak_ptr</code>s reference the control block, so it can be freed only when both counts reach zero."
            ],
            "guid": "dZCR7p9Nkj",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is <code>make_shared</code> more efficient than <code>shared_ptr(new T)</code>?",
                "<code>make_shared</code> performs a single allocation for both the object and control block, improving cache locality and reducing heap overhead compared to two separate allocations."
            ],
            "guid": "e:SbM]So&B",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does <code>weak_ptr</code> avoid dangling pointers?",
                "<code>weak_ptr::lock()</code> atomically checks the strong reference count and returns a valid <code>shared_ptr</code> only if the object still exists, otherwise returns an empty <code>shared_ptr</code>."
            ],
            "guid": "bwfTge+s#7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the key components of a minimal shared_ptr implementation?",
                "1. Control block with atomic strong/weak counters<br>2. Pointer to managed object<br>3. Proper copy/move/reset handling<br>4. Call deleter when last shared_ptr destroyed<br>5. Delete control block when weak count also zero"
            ],
            "guid": "Hcf[F3aA_9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does <code>shared_ptr</code> support polymorphism?",
                "Yes. <code>shared_ptr&lt;Derived&gt;</code> implicitly converts to <code>shared_ptr&lt;Base&gt;</code>, and the correct deleter is called because the control block stores the original type's destructor."
            ],
            "guid": "Hy;GAb|%=w",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What problem does <code>enable_shared_from_this</code> solve?",
                "It allows a class to safely obtain a <code>shared_ptr</code> to <code>this</code> from within member functions, avoiding creation of a second control block which would cause double deletion."
            ],
            "guid": "fW^1^LKdza",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is the control block related to <code>enable_shared_from_this</code>?",
                "The class stores a <code>weak_ptr</code> to itself that gets initialized when the first <code>shared_ptr</code> is created. Calling <code>shared_from_this()</code> locks this <code>weak_ptr</code> to return a <code>shared_ptr</code> sharing the same control block."
            ],
            "guid": "Mx5lpbVKFn",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do multiple inheritance and <code>shared_ptr</code> interact?",
                "Pointer adjustments are needed because the address of a base subobject may differ from the most-derived object. The control block stores the original pointer to ensure correct deletion."
            ],
            "guid": "v}^diJ!V&G",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers", "Inheritance"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the two main types of control blocks in <code>shared_ptr</code>?",
                "1. A control block for <code>shared_ptr(new T)</code> that stores a pointer to a separately allocated object.<br>2. A control block for <code>make_shared</code> that stores the object inline (single allocation)."
            ],
            "guid": "KB[vCd!1Ev",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is type erasure?",
                "A technique for hiding concrete types behind a uniform interface, typically using a base class with virtual functions or function pointers, allowing different types to be stored and manipulated polymorphically."
            ],
            "guid": "smJP{BFH-D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Erasure", "OOP"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>std::any</code> used for?",
                "Storing a value of any copyable type with type-safe runtime access. Useful when the stored type isn't known at compile time."
            ],
            "guid": "yV:Zej`JMx",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Erasure", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you retrieve the stored value from <code>std::any</code>?",
                "Use <code>std::any_cast&lt;T&gt;()</code> to extract the value. It throws <code>std::bad_any_cast</code> if the type doesn't match, or use the pointer overload which returns <code>nullptr</code> on mismatch."
            ],
            "guid": "M0H]jj!$iZ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Erasure", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if <code>std::any_cast</code> fails?",
                "Throws <code>std::bad_any_cast</code> (when using the reference overload). The pointer overload returns <code>nullptr</code> instead."
            ],
            "guid": "s|TQmgMb@G",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Erasure", "STL", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is <code>std::any</code> implemented internally?",
                "Via type erasure: a base class with virtual functions and a templated derived class that holds the actual value. Small buffer optimization is often used for small types."
            ],
            "guid": "s-~E+pegD(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Erasure", "STL"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does type erasure relate to smart pointers like <code>shared_ptr</code>?",
                "<code>shared_ptr</code> uses type erasure for custom deleters and allocators, allowing different deleter types without changing the <code>shared_ptr</code> template signature."
            ],
            "guid": "OeCMtuR/ex",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Type-Erasure", "Smart-Pointers"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>unique_ptr</code>?",
                "A smart pointer that provides exclusive ownership of a dynamically allocated object. It automatically deletes the object when the <code>unique_ptr</code> goes out of scope."
            ],
            "guid": "CRuyY)C{kv",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Smart-Pointers", "RAII"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is the copy constructor deleted in <code>unique_ptr</code>?",
                "To enforce exclusive ownership. Copying would create two owners of the same pointer, leading to double deletion. Use <code>std::move()</code> to transfer ownership instead."
            ],
            "guid": "cMzREu;b4u",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does the move constructor of <code>unique_ptr</code> work?",
                "It transfers ownership by copying the internal pointer to the new object and setting the source pointer to <code>nullptr</code>, leaving the moved-from <code>unique_ptr</code> in a valid but empty state."
            ],
            "guid": "KBVn6,0a3&",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Smart-Pointers", "Move-Semantics"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is <code>noexcept</code> used in move constructor and move assignment?",
                "To enable optimizations in containers like <code>std::vector</code>. If moves can throw, the container must use copies for strong exception safety. <code>noexcept</code> guarantees no exceptions during moves."
            ],
            "guid": "f~T$Kw4Ksz",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Move-Semantics", "Exceptions"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does the compiler deduce the type for <code>auto</code>?",
                "Using template argument deduction rules: references and cv-qualifiers on the initializer are dropped unless <code>auto&amp;</code> or <code>const auto&amp;</code> is used. Exception: braced initializers deduce to <code>std::initializer_list</code>."
            ],
            "guid": "jP/1.B5ebY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Type-Deduction", "Auto"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are attributes written in C++?",
                "Inside double square brackets: <code>[[nodiscard]]</code>, <code>[[deprecated]]</code>, <code>[[likely]]</code>. They can be applied to functions, variables, types, and statements."
            ],
            "guid": "rm33zNPm?~",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Attributes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>[[noreturn]]</code> do in C++?",
                "Indicates that a function never returns to its caller (e.g., <code>std::exit()</code>, <code>std::terminate()</code>, or functions that always throw). Enables compiler optimizations and diagnostics."
            ],
            "guid": "KqSO(ChAB9",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Attributes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>[[carries_dependency]]</code> do in C++?",
                "Hints to the compiler that dependency chains from function parameters or return values should be preserved, potentially avoiding memory fence instructions in lock-free code."
            ],
            "guid": "P&$V|dL`o.",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Expert", "Attributes", "Concurrency"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>[[fallthrough]]</code> do in C++?",
                "Indicates that falling through from one <code>case</code> label to the next in a <code>switch</code> statement is intentional, suppressing compiler warnings about missing <code>break</code>."
            ],
            "guid": "OcXk;M2{l:",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Attributes", "Control-Flow"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[nodiscard]] do in C++?",
                "Generates a warning if a function's return value is discarded. Useful for error codes, builders, and any value that shouldn't be ignored."
            ],
            "guid": "Gcymrn|x_j",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Attributes", "Best-Practices"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[maybe_unused]] do in C++?",
                "Suppresses compiler warnings for unused variables, parameters, or functions. Useful for conditional compilation or documentation parameters."
            ],
            "guid": "g,3ZTR?KY2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Beginner", "Attributes"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[likely]] do in C++?",
                "Hints to the compiler that a branch is expected to be taken frequently, enabling better code layout and branch prediction optimization (C++20)."
            ],
            "guid": "L]ht:.aQtD",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Attributes", "Optimization", "C++20"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[unlikely]] do in C++?",
                "Hints to the compiler that a branch is expected to be taken rarely, enabling better code layout for the common path (C++20)."
            ],
            "guid": "m~|q;[`dkY",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Attributes", "Optimization", "C++20"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[no_unique_address]] do in C++?",
                "Allows empty data members to overlap with other members, eliminating space overhead. Useful for stateless allocators, comparators, and other empty types (C++20)."
            ],
            "guid": "iy+JA,<Q{;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Attributes", "Optimization", "C++20"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[assume(expr)]] do in C++?",
                "Tells the compiler that the expression is always true, enabling aggressive optimizations. Undefined behavior if the assumption is violated (C++23)."
            ],
            "guid": "g2;-t7iG+l",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Attributes", "Optimization", "C++23"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[unsequenced]] do in C++?",
                "Indicates a function has no side effects or state, allowing the compiler to reorder, parallelize, or eliminate calls (C++26 proposal)."
            ],
            "guid": "zHt>PPOo8j",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Expert", "Attributes", "Optimization"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does [[reproducible]] do in C++?",
                "Indicates a function produces the same result for the same inputs (pure function), allowing parallel or relaxed evaluation (C++26 proposal)."
            ],
            "guid": "K@+h$:B}t(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Expert", "Attributes", "Concurrency"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>[[non_reproducible]]</code> do in C++?",
                "Explicitly marks a function as potentially producing different results for the same inputs (opposite of [[reproducible]])."
            ],
            "guid": "u#aX[.F5Si",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Expert", "Attributes", "Concurrency"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a type trait?",
                "A compile-time template that provides information about types, such as <code>std::is_pointer&lt;T&gt;</code> or <code>std::is_integral&lt;T&gt;</code>. Access the result via <code>::value</code> or the <code>_v</code> suffix."
            ],
            "guid": "q;-EcJXWhE",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Type-Traits"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>std::is_same&lt;T, U&gt;</code> do?",
                "Checks if two types are exactly the same at compile time. Use <code>std::is_same_v&lt;T, U&gt;</code> for the boolean value directly."
            ],
            "guid": "lt+2+Dm58C",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Type-Traits"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>std::remove_reference&lt;T&gt;</code> do?",
                "Removes <code>&amp;</code> or <code>&amp;&amp;</code> from a type. Use <code>std::remove_reference_t&lt;T&gt;</code> for the resulting type directly."
            ],
            "guid": "HU=b:&(K[D",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Type-Traits"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does <code>std::decay&lt;T&gt;</code> do?",
                "Applies the same type transformations as passing by value: removes references, applies array-to-pointer and function-to-pointer decay, and removes cv-qualifiers."
            ],
            "guid": "r4c#V`/pM%",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Type-Traits"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you define a custom type trait?",
                "Using template specialization. Define a primary template with a default value, then specialize for specific types or patterns."
            ],
            "guid": "Hb4!MTYD`;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Type-Traits"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is partial template specialization used for?",
                "To provide different implementations for specific type patterns (e.g., all pointer types, all references) while keeping a general primary template."
            ],
            "guid": "Rby&/K,ZPp",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can you overload templates for Metaprogramming?",
                "No. Function templates can be overloaded, but class templates can only be specialized. Use specialization for Metaprogramming."
            ],
            "guid": "y:r5qcHMzm",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Templates"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does SFINAE stand for?",
                "Substitution Failure Is Not An Error. When template argument substitution fails, the template is silently removed from overload resolution instead of causing a compile error."
            ],
            "guid": "Dyfw<|:D20",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When does SFINAE apply?",
                "During template argument substitution in the immediate context. If substitution fails, that overload is discarded. Errors in non-immediate contexts (like function bodies) still cause hard errors."
            ],
            "guid": "GP.40!WnFS",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does NOT cause SFINAE?",
                "Errors inside function bodies, syntax errors unrelated to substitution, and errors in non-immediate contexts. These cause hard compile errors."
            ],
            "guid": "G,Ua/{Iicb",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <code>std::enable_if_t&lt;condition&gt;</code> used for?",
                "Conditionally enabling or disabling function templates based on compile-time boolean conditions. If the condition is false, substitution fails and SFINAE removes the overload."
            ],
            "guid": "CJU@wMklPJ",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Give a simple example of SFINAE.",
                "Using <code>std::enable_if</code> to restrict a template to integral types:<br><pre><code class=\"language-cpp\">template&lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, int&gt; = 0&gt;\nvoid f(T) {}</code></pre>"
            ],
            "guid": "ls68ZE}X~}",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can SFINAE be used with non-type template parameters?",
                "Yes, via <code>std::enable_if</code> or concepts in C++20."
            ],
            "guid": "Mk`JY510CW",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why does std::is_class use SFINAE internally?&nbsp;",
                "To check int T::* which is valid only for class/struct types; if T is not a class, substitution fails but doesn't break compilation."
            ],
            "guid": "HvLnX3v3a*",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is SFINAE considered part of the template substitution phase?&nbsp;",
                "Because failures are checked **while substituting template parameters**, before overload resolution."
            ],
            "guid": "PQ+z%[<jRI",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can SFINAE distinguish between a <b>struct</b>&nbsp;and a <b>class</b>?&nbsp;",
                "No, because both are treated as class type in C++ type system."
            ],
            "guid": "i:wb63a4z8",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is <b>std::enable_if</b>&nbsp;used for?&nbsp;",
                "To enable or disable a template based on a compile-time condition."
            ],
            "guid": "pXI[++a=;J",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Can <code>std::enable_if</code> be used in a function return type?",
                "Yes:<br><pre><code class=\"language-cpp\">template&lt;typename T&gt;\nstd::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; f(T);</code></pre>"
            ],
            "guid": "cQ$ri`ZO/l",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between using <code>enable_if</code> in a parameter vs return type?",
                "<b>Parameter:</b> Adds a dummy argument to disable the overload.<br><b>Return type:</b> Controls whether the function exists at all."
            ],
            "guid": "C}EKGgR-9;",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is a <b>requires</b> clause evaluated?",
                "Before template overload resolution, during constraint satisfaction."
            ],
            "guid": "caF^(G={/F",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why are two functions with the same signature but different <code>requires</code> clauses treated as different overloads?",
                "Because constraints are part of a template's identity. Different constraints create distinct overload candidates."
            ],
            "guid": "h1GTPYM:<z",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if two templates match but one has stronger constraints?",
                "The more constrained template is preferred (partial ordering of constraints)."
            ],
            "guid": "K/A*+_}0+a",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why can't you put a <code>requires</code> clause on a non-template function?",
                "Because constraints are evaluated during template instantiation. Non-template functions have no template parameters to constrain."
            ],
            "guid": "JggFjj5ZYM",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Does a failing <code>requires</code> clause participate in SFINAE?",
                "No. Constraint failure removes the template before SFINAE occurs. The template is never even considered as an overload candidate."
            ],
            "guid": "P{eVXSLb+2",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if a <code>requires</code> expression contains invalid code?",
                "Invalid code inside a <code>requires</code> expression causes the requirement to evaluate to false, not a hard compile error. This is similar to SFINAE behavior."
            ],
            "guid": "F}zYMDgSAT",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does <code>std::enable_if</code> differ from <code>requires</code>?",
                "<code>enable_if</code> uses SFINAE during substitution and has awkward syntax. <code>requires</code> uses constraint evaluation, happens earlier, and provides clearer error messages."
            ],
            "guid": "d_6f^gbTbn",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Concepts", "SFINAE"]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are associated constraints?",
                "All constraints attached to a template declaration: <code>requires</code> clauses, constrained template parameters (e.g., <code>template&lt;std::integral T&gt;</code>), and nested requires-expressions."
            ],
            "guid": "D8~n:Y8cm7",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Advanced", "Metaprogramming", "Concepts"]
        },
        {
            "__type__": "Note",
            "fields": [
                "Are these two declarations equivalent?<br><br><code>template &lt;typename T&gt; requires C&lt;T&gt; void f(T);</code><br><br><code>template &lt;typename T&gt; void f(T) requires C&lt;T&gt;;</code>",
                "Yes. Both attach the same constraint to the function template. The requires clause can appear before or after the function signature."
            ],
            "guid": "zKH5:TdVW(",
            "note_model_uuid": "4ff54864-cf8d-11f0-98d8-1d42bb598edb",
            "tags": ["Intermediate", "Metaprogramming", "Concepts"]
        }
    ],
    "reviewLimit": null,
    "reviewLimitToday": null
}